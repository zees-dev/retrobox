<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroBox Controller</title>
    <script>
        // Screen Wake Lock - keep screen on while controller is active
        let wakeLock = null;
        async function requestWakeLock() {
            if (!('wakeLock' in navigator)) return;
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                wakeLock.addEventListener('release', () => console.log('Wake Lock released'));
                console.log('Wake Lock acquired');
            } catch (e) {
                console.log('Wake Lock error:', e.message);
            }
        }
        // Request on load and re-acquire when page becomes visible
        requestWakeLock();
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') requestWakeLock();
        });
    </script>
    <style>
        * { box-sizing: border-box; }
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #1a1a1a; font-family: Arial, sans-serif; position: fixed; top: 0; left: 0; }
        #game { position: fixed; inset: 0; width: 100vw; height: 100vh; width: 100dvw; height: 100dvh; }
        .loading { color: #fff; text-align: center; padding: 20px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .player-status { position: fixed; top: 15px; left: 15px; z-index: 9999; display: flex; flex-direction: column; align-items: center; gap: 4px; opacity: 0; transition: opacity 0.3s; }
        .player-status.visible { opacity: 1; }
        .status-dot { position: relative; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; color: #fff; font-family: Arial, sans-serif; transition: all 0.3s; }
        .status-dot.connecting { background: #FF9800; opacity: 0.5; animation: blink 1s ease-in-out infinite; }
        .status-dot.connected { animation: breathe 2s ease-in-out infinite; }
        .status-dot.player-0 { background: #4CAF50; box-shadow: 0 0 15px rgba(76, 175, 80, 0.6); }
        .status-dot.player-1 { background: #2196F3; box-shadow: 0 0 15px rgba(33, 150, 243, 0.6); }
        .status-dot.player-2 { background: #9C27B0; box-shadow: 0 0 15px rgba(156, 39, 176, 0.6); }
        .status-dot.player-3 { background: #FFC107; box-shadow: 0 0 15px rgba(255, 193, 7, 0.6); }
        .status-dot.error { background: #f44336; box-shadow: 0 0 15px rgba(244, 67, 54, 0.6); }
        .status-dot.p2p::after { content: ''; position: absolute; bottom: -1px; right: -1px; width: 6px; height: 6px; background: #00ff00; border-radius: 50%; }
        @keyframes blink { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        @keyframes breathe { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.05); opacity: 0.9; } }

        .ping-badge { font-size: 11px; font-family: monospace; font-weight: bold; }
        .ping-badge.ping-good { color: #4CAF50; }
        .ping-badge.ping-ok { color: #FFEB3B; }
        .ping-badge.ping-warn { color: #FF9800; }
        .ping-badge.ping-bad { color: #f44336; }

        .test-controller { position: fixed; top: 59px; right: 15px; z-index: 999; pointer-events: auto; }
        .test-controller.hidden { display: none; }
        .test-controller-toggle { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.25); border-radius: 6px; font-size: 20px; cursor: pointer; transition: all 0.3s; }
        .test-controller-toggle:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.4); transform: scale(1.05); }
        .test-controller.expanded .test-controller-toggle { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.4); }
        .test-controller-links { display: none; flex-direction: column; gap: 6px; margin-top: 8px; padding: 10px; background: rgba(0, 0, 0, 0.9); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; min-width: 180px; position: absolute; right: 0; }
        .test-controller.expanded .test-controller-links { display: flex; }
        .test-controller-link { display: flex; align-items: center; justify-content: center; height: 36px; padding: 0 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #1AAFFF; text-decoration: none; font-size: 12px; white-space: nowrap; transition: all 0.3s; }
        .test-controller-link:hover { background: rgba(255, 255, 255, 0.15); border-color: #1AAFFF; }
    </style>
</head>
<body>
    <div id="game"><div class="loading">Mobile Controller</div></div>
    <div class="player-status" id="playerStatus">
        <div class="status-dot" id="statusDot"></div>
        <div class="ping-badge" id="pingBadge"></div>
    </div>
    <div class="test-controller" id="testController">
        <button class="test-controller-toggle" id="testControllerToggle" title="Test Controller">ðŸŽ®</button>
        <div class="test-controller-links">
            <a href="https://hardwaretester.com/gamepad" target="_blank" rel="noopener" class="test-controller-link">hardwaretester.com</a>
            <a href="https://gamepadtester.com/" target="_blank" rel="noopener" class="test-controller-link">gamepadtester.com</a>
        </div>
    </div>
    <game-menu id="gameMenu" mode="controller" show-manual-config="false"></game-menu>

    <script type="text/javascript">
        // ============================================
        // CONSTANTS
        // ============================================
        const HEARTBEAT_INTERVAL = 3000;

        // EmulatorJS config
        EJS_player = '#game';
        EJS_pathtodata = 'EmulatorJS/data/';
        EJS_controlsOnly = true;
        EJS_DEBUG_XX = true;
        EJS_disableAutoLang = true;
        EJS_language = "en";

        // Button config (base - modified per player in handleGameStarted)
        const buttonConfig = {
            playPause: true, restart: false, mute: true, settings: true, fullscreen: true,
            saveState: false, loadState: false, quickSave: false, quickLoad: false,
            gamepad: true, cheat: false, volume: true, diskButton: false,
            netplay: false, screenRecord: false, saveSavFiles: false, loadSavFiles: false,
            screenshot: false, cacheManager: false, exitEmulation: false,
            toggleFPS: {
                displayName: "FPS",
                icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 24" fill="currentColor"><text x="20" y="18" font-size="24" font-weight="bold" text-anchor="middle" font-family="Arial,sans-serif">FPS</text></svg>',
                callback: () => sendToScreen({ type: 'toggleFPS' })
            },
            remoteSave: {
                displayName: "Save State",
                icon: '<svg viewBox="0 0 448 512"><path fill="currentColor" d="M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"/></svg>',
                callback: () => sendToScreen({ type: 'saveState', slot: 1 })
            },
            remoteLoad: {
                displayName: "Load State",
                icon: '<svg viewBox="0 0 576 512"><path fill="currentColor" d="M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z"/></svg>',
                callback: () => sendToScreen({ type: 'loadState', slot: 1 })
            },
            home: {
                displayName: "Menu",
                icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>',
                callback: () => sendToScreen({ type: 'resetToMenu' })
            }
        };
        EJS_Buttons = buttonConfig;

        // ============================================
        // STATE
        // ============================================
        let ws = null;
        let playerNumber = null;
        let heartbeatInterval = null;
        let emulatorLoaded = false;
        let currentCore = null;
        let gameMenu = null;

        const urlParams = new URLSearchParams(window.location.search);
        const screenId = urlParams.get('screen');
        const requestedPlayer = urlParams.get('p') ? parseInt(urlParams.get('p'), 10) : null;

        // Generate unique controller ID per session (new tab = new player)
        const controllerId = Array.from(crypto.getRandomValues(new Uint8Array(8)), b => b.toString(16).padStart(2, '0')).join('');

        // ============================================
        // WEBRTC P2P (Zero-allocation hot path)
        // ============================================
        let pc = null, inputChannel = null, currentRtt = 0;
        let iceCandidateBuffer = [], remoteDescSet = false;

        // Pre-allocated send buffer (Worker 3 pattern)
        const txBuf = new ArrayBuffer(16);
        const txView = new DataView(txBuf);
        const txBytes = new Uint8Array(txBuf);

        // Pre-allocated button state array (zero-allocation pattern)
        // Buttons 0-23, using 32 for alignment. Value: 0=released, 1=pressed, 255=uninitialized
        const lastButtonState = new Uint8Array(32);
        lastButtonState.fill(255); // Mark all as uninitialized (first message always sends)

        function connectP2P() {
            if (pc) try { pc.close(); } catch {}
            pc = new RTCPeerConnection({ iceServers: [] });
            iceCandidateBuffer = [];
            remoteDescSet = false;

            inputChannel = pc.createDataChannel('input', { ordered: false, maxRetransmitTime: 50 });
            inputChannel.binaryType = 'arraybuffer';

            inputChannel.onopen = () => {
                console.log('[WebRTC] DataChannel open');
                document.getElementById('statusDot').classList.add('p2p');
                lastButtonState.fill(255); // Reset to uninitialized (first message always sends)
            };

            inputChannel.onclose = () => {
                console.log('[WebRTC] DataChannel closed');
                document.getElementById('statusDot').classList.remove('p2p');
            };

            inputChannel.onerror = e => console.error('[WebRTC] DataChannel error:', e);

            inputChannel.onmessage = e => {
                // RTT echo from screen (4 bytes = timestamp)
                const echoTs = new Uint32Array(e.data)[0];
                currentRtt = ((performance.now() | 0) - echoTs) & 0xFFFF;
                // Send ping report (methodId=0, rtt in bytes 5-6 as uint16 LE)
                txView.setUint8(0, 0);
                txView.setUint32(1, performance.now() | 0, false);
                txView.setUint16(5, currentRtt, true);
                inputChannel.send(new Uint8Array(txBuf, 0, 7));
            };

            pc.onicecandidate = e => {
                if (e.candidate && ws?.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ice-candidate', candidate: e.candidate }));
                }
            };

            pc.onconnectionstatechange = () => {
                console.log('[WebRTC] Connection state:', pc.connectionState);
                if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    document.getElementById('statusDot').classList.remove('p2p');
                }
            };

            pc.createOffer().then(offer => {
                pc.setLocalDescription(offer);
                ws.send(JSON.stringify({ type: 'webrtc-offer', offer }));
                console.log('[WebRTC] Sent offer');
            });
        }

        function handleRemoteAnswer(answer) {
            if (!pc) return;
            pc.setRemoteDescription(answer).then(() => {
                remoteDescSet = true;
                // Flush buffered ICE candidates (Worker 2 pattern)
                iceCandidateBuffer.forEach(c => pc.addIceCandidate(c).catch(() => {}));
                iceCandidateBuffer = [];
            });
        }

        function handleRemoteIceCandidate(candidate) {
            if (!pc) return;
            if (remoteDescSet) {
                pc.addIceCandidate(candidate).catch(() => {});
            } else {
                iceCandidateBuffer.push(candidate);
            }
        }

        // Analog stick axes (indices 16-23 use 0-0x7fff values)
        const ANALOG_AXES = new Set([16, 17, 18, 19, 20, 21, 22, 23]);

        // Send input over P2P DataChannel. Returns true if sent (or suppressed due to no state change).
        // Protocol: [methodId:1][timestamp:4][button:1][value:1-2]
        function sendP2PInput(button, value, isAnalog) {
            if (!inputChannel || inputChannel.readyState !== 'open') return false;

            // For digital buttons, only send on state change (O(1) array lookup)
            if (!isAnalog) {
                if (lastButtonState[button] === value) {
                    return true; // Already in this state, suppress but don't fallback to WS
                }
                lastButtonState[button] = value;
            }

            txView.setUint32(1, performance.now() | 0, false);
            txBytes[5] = button;

            if (isAnalog) {
                txView.setUint8(0, 2);
                txView.setUint16(6, value & 0xFFFF, true);
                inputChannel.send(new Uint8Array(txBuf, 0, 8));
            } else {
                txView.setUint8(0, 1);
                txBytes[6] = value;
                inputChannel.send(new Uint8Array(txBuf, 0, 7));
            }
            return true;
        }

        // ============================================
        // WEBSOCKET
        // ============================================
        function getWebSocketUrl() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            return `${protocol}//${window.location.host}/ws`;
        }

        function sendToScreen(msg) {
            if (ws?.readyState === WebSocket.OPEN) ws.send(JSON.stringify(msg));
        }

        function updateStatus(state, playerNum = null, errorMsg = null) {
            const playerStatus = document.getElementById('playerStatus');
            const dot = document.getElementById('statusDot');
            const badge = document.getElementById('pingBadge');
            dot.className = 'status-dot ' + state;
            document.body.className = '';
            if (state === 'connected' && playerNum !== null) {
                dot.classList.add(`player-${playerNum}`);
                dot.textContent = `P${playerNum + 1}`;
                document.body.classList.add('connected', `player-${playerNum}`);
                playerStatus.classList.add('visible');
                badge.textContent = '';
            } else if (state === 'connecting') {
                dot.textContent = '';
                badge.textContent = '';
                playerStatus.classList.add('visible');
            } else if (state === 'error') {
                dot.textContent = 'âœ•';
                if (errorMsg) badge.textContent = errorMsg;
                badge.className = 'ping-badge ping-bad';
                playerStatus.classList.add('visible');
            } else {
                playerStatus.classList.remove('visible');
            }
        }

        function updatePingDisplay(rtt) {
            const badge = document.getElementById('pingBadge');
            badge.textContent = rtt + 'ms';
            badge.className = 'ping-badge';
            if (rtt <= 50) badge.classList.add('ping-good');
            else if (rtt <= 100) badge.classList.add('ping-ok');
            else if (rtt <= 150) badge.classList.add('ping-warn');
            else badge.classList.add('ping-bad');
        }

        function connectWebSocket() {
            if (ws?.readyState === WebSocket.OPEN) return;
            if (!screenId) { console.error('No screen ID in URL'); return; }

            updateStatus('connecting');
            ws = new WebSocket(getWebSocketUrl());

            ws.onopen = () => {
                console.log('WebSocket connected, registering as controller:', controllerId, 'for screen:', screenId, requestedPlayer !== null ? `(requesting P${requestedPlayer})` : '');
                const registerMsg = { type: 'register-controller', controllerId, screenId };
                if (requestedPlayer !== null && requestedPlayer >= 1 && requestedPlayer <= 4) {
                    registerMsg.requestedPlayerNum = requestedPlayer - 1; // Convert to 0-indexed
                }
                ws.send(JSON.stringify(registerMsg));

                clearInterval(heartbeatInterval);
                heartbeatInterval = setInterval(() => {
                    if (ws?.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: 'heartbeat' }));
                }, HEARTBEAT_INTERVAL);
            };

            ws.onmessage = e => handleMessage(JSON.parse(e.data));

            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                updateStatus('connecting');
                clearInterval(heartbeatInterval);
                playerNumber = null;
                setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = err => console.error('WebSocket error:', err);
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'registered':
                    playerNumber = msg.playerNum;
                    console.log('Controller registered, Player', playerNumber + 1);
                    updateStatus('connected', playerNumber);
                    gameMenu?.setWebSocket(ws);
                    connectP2P();
                    break;

                case 'webrtc-answer':
                    handleRemoteAnswer(msg.answer);
                    break;

                case 'ice-candidate':
                    handleRemoteIceCandidate(msg.candidate);
                    break;

                case 'error':
                    console.error('Server error:', msg.error);
                    if (msg.code === 'player-slot-taken') {
                        // Player slot already taken - show message and don't reconnect
                        updateStatus('error', null, `P${msg.requestedPlayer} taken`);
                        clearInterval(heartbeatInterval);
                        ws.close();
                        ws = null;
                    }
                    break;

                case 'screen-disconnected':
                    console.log('Screen disconnected');
                    updateStatus('connecting');
                    playerNumber = null;
                    break;

                case 'stateUpdate':
                    handleStateUpdate(msg);
                    break;

                case 'hardRefresh':
                    console.log('Hard refresh requested by screen');
                    window.location.reload();
                    break;

                case 'heartbeat-ack':
                    break;

                case 'settingsSync':
                    // Apply settings from screen to local EmulatorJS instance
                    if (msg.settings && window.EJS_emulator?.handler) {
                        console.log('Syncing settings from screen:', Object.keys(msg.settings).length, 'settings');
                        for (const [setting, value] of Object.entries(msg.settings)) {
                            try {
                                EJS_emulator.handler.exec('settings.change', { setting, value });
                            } catch (e) { /* ignore individual setting errors */ }
                        }
                    }
                    break;
            }
        }

        connectWebSocket();

        // ============================================
        // STATE HANDLERS
        // ============================================
        function handleStateUpdate(data) {
            console.log('State update:', data);
            if (data.state === 'game-ready') handleGameStarted(data.core);
            else if (data.state === 'game-selection') handleGameReset();
            else if (data.state === 'game-pending') {
                gameMenu?.setLoadingText(`Loading ${data.gameName || 'game'}...`);
                gameMenu?.showLoading();
            }
        }

        function handleGameStarted(core) {
            console.log('Game started, core:', core);
            gameMenu?.hide();
            document.getElementById('gameMenu')?.style.setProperty('display', 'none');
            document.getElementById('game').style.display = 'block';
            document.getElementById('testController').classList.add('hidden');

            if (!emulatorLoaded || currentCore !== core) {
                currentCore = core;
                window.EJS_core = core || 'arcade';
                if (emulatorLoaded && window.EJS_emulator) {
                    document.getElementById('game').innerHTML = '';
                    window.EJS_emulator = null;
                }
                // P1 only: restart and home menu
                const isP1 = playerNumber === 0;
                window.EJS_Buttons = {
                    ...buttonConfig,
                    restart: isP1,
                    home: isP1 ? buttonConfig.home : false
                };
                const script = document.createElement('script');
                script.src = 'EmulatorJS/data/loader.js';
                script.onload = () => {
                    console.log('EmulatorJS loaded');
                    emulatorLoaded = true;
                    // Request settings sync from screen after EmulatorJS is ready
                    setTimeout(() => requestSettingsSync(), 500);
                };
                document.body.appendChild(script);
            }
        }

        function requestSettingsSync() {
            if (ws?.readyState === WebSocket.OPEN) {
                sendToScreen({ type: 'getSettings' });
                console.log('Requested settings sync from screen');
            }
        }

        function handleGameReset() {
            console.log('Game reset');
            if (window.EJS_emulator) try { window.EJS_emulator = null; } catch {}
            emulatorLoaded = false;
            currentCore = null;
            document.getElementById('game').innerHTML = '';
            document.getElementById('game').style.display = 'none';
            gameMenu?.show();
            document.getElementById('gameMenu')?.style.setProperty('display', '');
            document.getElementById('testController').classList.remove('hidden');
        }

        // ============================================
        // EMULATORJS CALLBACKS
        // ============================================
        EJS_ready = () => console.log('EmulatorJS ready');
        EJS_onCommand = event => {
            if (event.method === 'control.fullscreen') return;

            // Handle settings changes - send as explicit setSetting message
            if (event.method === 'settings.change' && event.params) {
                console.log('Setting changed locally:', event.params.setting, '=', event.params.value);
                sendToScreen({ type: 'setSetting', setting: event.params.setting, value: event.params.value });
                return;
            }

            if (event.method === 'input.simulate' && event.params) {
                const { button, state, value } = event.params;
                const isAnalog = state === 'analog' || ANALOG_AXES.has(button);
                const inputValue = isAnalog ? (value || 0) : (state === 'pressed' || value === 1 ? 1 : 0);

                if (sendP2PInput(button, inputValue, isAnalog)) return;

                // WebSocket fallback: also deduplicate (O(1) array lookup)
                if (!isAnalog) {
                    if (lastButtonState[button] === inputValue) return;
                    lastButtonState[button] = inputValue;
                }

                event.params.player = playerNumber ?? 0;
            }
            sendToScreen(event);
        };

        // ============================================
        // GAME MENU
        // ============================================
        async function loadGameMenuComponent() {
            try {
                const res = await fetch('game-menu.html');
                const html = await res.text();
                const doc = new DOMParser().parseFromString(html, 'text/html');
                const script = doc.querySelector('script[type="module"]');
                if (script) {
                    const el = document.createElement('script');
                    el.type = 'module';
                    el.textContent = script.textContent;
                    document.head.appendChild(el);
                    await customElements.whenDefined('game-menu');
                    gameMenu = document.getElementById('gameMenu');
                    document.getElementById('game').style.display = 'none';
                    if (ws?.readyState === WebSocket.OPEN) gameMenu?.setWebSocket(ws);
                }
            } catch(e) { console.error('Failed to load game menu:', e); }
        }
        loadGameMenuComponent();

        window.addEventListener('beforeunload', () => {
            clearInterval(heartbeatInterval);
            if (pc) try { pc.close(); } catch {}
            ws?.close();
        });

        document.getElementById('testControllerToggle').onclick = () => {
            document.getElementById('testController').classList.toggle('expanded');
        };
    </script>
</body>
</html>
