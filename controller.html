<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroBox Controller</title>
    <script>
        // Disable WakeLock by intercepting errors
        const originalRequest = navigator.wakeLock?.request;
        if (originalRequest) {
            navigator.wakeLock.request = async function(...args) {
                try { return await originalRequest.apply(this, args); }
                catch (e) {
                    console.log('WakeLock error caught:', e.message);
                    return { released: false, type: args[0], release: async () => {}, addEventListener: () => {}, removeEventListener: () => {} };
                }
            };
        }
    </script>
    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #1a1a1a; font-family: Arial, sans-serif; position: fixed; top: 0; left: 0; }
        #game { position: fixed; inset: 0; width: 100vw; height: 100vh; width: 100dvw; height: 100dvh; }
        .loading { color: #fff; text-align: center; padding: 20px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .status-dot { position: fixed; top: 15px; right: 15px; width: 12px; height: 12px; border-radius: 50%; z-index: 9999; transition: all 0.3s; opacity: 0; pointer-events: none; }
        .status-dot.connecting { background: #FF9800; opacity: 0.5; animation: blink 1s ease-in-out infinite; }
        .status-dot.connected { opacity: 1; animation: breathe 2s ease-in-out infinite; }
        .status-dot.player-0 { background: #4CAF50; box-shadow: 0 0 15px rgba(76, 175, 80, 0.6); }
        .status-dot.player-1 { background: #2196F3; box-shadow: 0 0 15px rgba(33, 150, 243, 0.6); }
        .status-dot.player-2 { background: #9C27B0; box-shadow: 0 0 15px rgba(156, 39, 176, 0.6); }
        .status-dot.player-3 { background: #FFC107; box-shadow: 0 0 15px rgba(255, 193, 7, 0.6); }
        @keyframes blink { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        @keyframes breathe { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.8; } }

        .test-controller { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 999; width: max(280px, 25vw); max-width: 85vw; pointer-events: auto; }
        .test-controller.hidden { display: none; }
        .test-controller-toggle { width: 100%; height: 45px; display: flex; align-items: center; justify-content: center; gap: 10px; background: rgba(0, 0, 0, 0.8); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: rgba(255, 255, 255, 0.8); font-size: 15px; cursor: pointer; transition: all 0.3s; }
        .test-controller-toggle:hover { background: rgba(0, 0, 0, 0.9); border-color: rgba(255, 255, 255, 0.3); color: #fff; }
        .test-controller-toggle .emoji { font-size: 20px; }
        .test-controller-toggle .arrow { font-size: 12px; transition: transform 0.3s; }
        .test-controller.expanded .test-controller-toggle .arrow { transform: rotate(180deg); }
        .test-controller-links { display: none; flex-direction: column; gap: 8px; margin-top: 8px; padding: 12px; background: rgba(0, 0, 0, 0.8); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; }
        .test-controller.expanded .test-controller-links { display: flex; }
        .test-controller-link { display: flex; align-items: center; justify-content: center; height: 40px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #1AAFFF; text-decoration: none; font-size: 14px; transition: all 0.3s; }
        .test-controller-link:hover { background: rgba(255, 255, 255, 0.15); border-color: #1AAFFF; }

        @media (orientation: landscape) and (max-height: 600px) {
            .test-controller { bottom: 10px; width: max(250px, 20vw); }
            .test-controller-toggle { height: 38px; font-size: 14px; }
            .test-controller-links { padding: 10px; gap: 6px; }
            .test-controller-link { height: 35px; font-size: 13px; }
        }
    </style>
</head>
<body>
    <div id="game"><div class="loading">Mobile Controller</div></div>
    <div class="status-dot" id="statusDot"></div>
    <div class="test-controller" id="testController">
        <button class="test-controller-toggle" id="testControllerToggle">
            <span class="emoji">+</span>
            <span>Test Controller</span>
            <span class="arrow">v</span>
        </button>
        <div class="test-controller-links">
            <a href="https://hardwaretester.com/gamepad" target="_blank" rel="noopener" class="test-controller-link">hardwaretester.com/gamepad</a>
            <a href="https://gamepadtester.com/" target="_blank" rel="noopener" class="test-controller-link">gamepadtester.com</a>
        </div>
    </div>
    <game-menu id="gameMenu" mode="controller" show-manual-config="false"></game-menu>

    <script type="text/javascript">
        // ============================================
        // CONSTANTS - Aligned with screen.html
        // ============================================
        const HEARTBEAT_INTERVAL = 3000;
        const HEARTBEAT_TIMEOUT = 8000;

        // EmulatorJS config
        EJS_player = '#game';
        EJS_pathtodata = 'EmulatorJS/data/';
        EJS_controlsOnly = true;
        EJS_DEBUG_XX = true;

        // Button config (defined once, reused)
        // Hide built-in save/load buttons, use custom buttons that send commands to screen
        const buttonConfig = {
            playPause: true, restart: true, mute: true, settings: true, fullscreen: true,
            saveState: false, loadState: false, quickSave: false, quickLoad: false,
            gamepad: true, cheat: true, volume: true,
            netplay: false, screenRecord: false, saveSavFiles: false, loadSavFiles: false,
            screenshot: false, cacheManager: false, exitEmulation: false,
            // Custom buttons that send commands to screen (which holds canonical state)
            remoteSave: {
                displayName: "Save State",
                icon: '<svg viewBox="0 0 448 512"><path fill="currentColor" d="M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"/></svg>',
                callback: () => { if (displayConn?.open) displayConn.send({ type: 'saveState', slot: 1 }); }
            },
            remoteLoad: {
                displayName: "Load State",
                icon: '<svg viewBox="0 0 576 512"><path fill="currentColor" d="M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z"/></svg>',
                callback: () => { if (displayConn?.open) displayConn.send({ type: 'loadState', slot: 1 }); }
            },
            home: {
                displayName: "Menu",
                icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>',
                callback: () => { if (displayConn?.open) displayConn.send({ type: 'resetToMenu' }); }
            }
        };
        EJS_Buttons = buttonConfig;

        // ============================================
        // STATE
        // ============================================
        let peer, displayConn;
        let heartbeatInterval, heartbeatCheckInterval;
        let playerNumber = null;
        let lastScreenAck = 0;
        let emulatorLoaded = false;
        let currentCore = null;
        let gameMenu = null;

        // ============================================
        // PEERJS
        // ============================================
        function initializePeer() {
            const array = new Uint8Array(8);
            crypto.getRandomValues(array);
            const id = Array.from(array, b => b.toString(16).padStart(2, '0')).join('').substr(0, 6);

            peer = new Peer(id, { config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] } });
            peer.on('open', () => { console.log('Controller ready:', id); updateStatus('connecting'); setTimeout(autoConnect, 1000); });
            peer.on('error', e => { console.error('Peer error:', e); updateStatus('disconnected'); });
        }

        function updateStatus(state, playerNum = null) {
            const dot = document.getElementById('statusDot');
            dot.className = 'status-dot ' + state;
            document.body.className = '';
            if (state === 'connected' && playerNum !== null) {
                dot.classList.add(`player-${playerNum}`);
                document.body.classList.add('connected', `player-${playerNum}`);
            }
        }

        function connectToScreen() {
            if (!peer || displayConn?.open) return;
            displayConn = peer.connect('emulator-screen');

            displayConn.on('open', () => {
                console.log('Connected to screen');
                gameMenu?.setPeerConnection(displayConn);

                // Start heartbeat - aligned with screen timing
                clearInterval(heartbeatInterval);
                heartbeatInterval = setInterval(() => {
                    if (displayConn?.open) displayConn.send({ type: 'heartbeat' });
                }, HEARTBEAT_INTERVAL);

                // Monitor screen responses
                lastScreenAck = Date.now();
                clearInterval(heartbeatCheckInterval);
                heartbeatCheckInterval = setInterval(() => {
                    if (Date.now() - lastScreenAck > HEARTBEAT_TIMEOUT) {
                        console.log('Screen timeout');
                        displayConn?.close();
                        setTimeout(autoConnect, 1000);
                    }
                }, HEARTBEAT_INTERVAL);
            });

            displayConn.on('data', data => {
                if (data.type === 'ack') { lastScreenAck = Date.now(); return; }
                if (data.type === 'playerAssignment') {
                    playerNumber = data.playerNumber;
                    console.log('Assigned Player', playerNumber + 1);
                    updateStatus('connected', playerNumber);
                }
                if (data.type === 'stateUpdate') handleStateUpdate(data);
            });

            displayConn.on('close', () => handleDisconnect());
            displayConn.on('error', () => handleDisconnect());
        }

        function handleDisconnect() {
            console.log('Disconnected');
            updateStatus('disconnected');
            clearInterval(heartbeatInterval);
            clearInterval(heartbeatCheckInterval);
            playerNumber = null;
            gameMenu?.setPeerConnection(null);
            displayConn = null;
            setTimeout(autoConnect, 2000);
        }

        function autoConnect() {
            if (!peer || displayConn?.open) return;
            console.log('Auto-connecting...');
            updateStatus('connecting');
            connectToScreen();
        }

        // Periodic reconnect check
        setInterval(() => { if (peer && !displayConn?.open) autoConnect(); }, 5000);

        initializePeer();

        // ============================================
        // STATE HANDLERS
        // ============================================
        function handleStateUpdate(data) {
            console.log('State update:', data);
            if (data.state === 'game-ready') handleGameStarted(data.core);
            else if (data.state === 'game-selection') handleGameReset();
            else if (data.state === 'game-pending') gameMenu?.setLoadingText(`Loading ${data.gameName || 'game'}...`);
        }

        function handleGameStarted(core) {
            console.log('Game started, core:', core);
            gameMenu?.hide();
            document.getElementById('game').style.display = 'block';
            document.getElementById('testController').classList.add('hidden');

            if (!emulatorLoaded || currentCore !== core) {
                currentCore = core;
                window.EJS_core = core || 'arcade';
                if (emulatorLoaded && window.EJS_emulator) {
                    document.getElementById('game').innerHTML = '';
                    window.EJS_emulator = null;
                }
                window.EJS_Buttons = { ...buttonConfig, home: { ...buttonConfig.home, callback: () => { if (displayConn?.open) displayConn.send({ type: 'resetToMenu' }); } } };
                const script = document.createElement('script');
                script.src = 'EmulatorJS/data/loader.js';
                script.onload = () => { console.log('EmulatorJS loaded'); emulatorLoaded = true; };
                document.body.appendChild(script);
            }
        }

        function handleGameReset() {
            console.log('Game reset');
            gameMenu?.show();
            document.getElementById('game').style.display = 'none';
            document.getElementById('testController').classList.remove('hidden');
        }

        // ============================================
        // EMULATORJS CALLBACKS
        // ============================================
        EJS_ready = () => console.log('EmulatorJS ready');
        EJS_onCommand = event => {
            if (event.method === 'control.fullscreen') return;
            if (event.method === 'input.simulate') event.params.player = playerNumber ?? 0;
            if (displayConn?.open) displayConn.send(event);
        };

        // ============================================
        // GAME MENU
        // ============================================
        async function loadGameMenuComponent() {
            try {
                const res = await fetch('game-menu.html');
                const html = await res.text();
                const doc = new DOMParser().parseFromString(html, 'text/html');
                const script = doc.querySelector('script[type="module"]');
                if (script) {
                    const el = document.createElement('script');
                    el.type = 'module';
                    el.textContent = script.textContent;
                    document.head.appendChild(el);
                    await customElements.whenDefined('game-menu');
                    gameMenu = document.getElementById('gameMenu');
                    document.getElementById('game').style.display = 'none';
                    if (displayConn) gameMenu?.setPeerConnection(displayConn);
                }
            } catch(e) { console.error('Failed to load game menu:', e); }
        }
        loadGameMenuComponent();

        // Cleanup
        window.addEventListener('beforeunload', () => {
            clearInterval(heartbeatInterval);
            clearInterval(heartbeatCheckInterval);
            displayConn?.close();
            peer?.destroy();
        });

        // Test controller toggle
        document.getElementById('testControllerToggle').onclick = () => {
            document.getElementById('testController').classList.toggle('expanded');
        };
    </script>
</body>
</html>
