<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroBox Controller</title>
    <script>
        // Screen Wake Lock - keep screen on while controller is active
        // Uses native Wake Lock API if available, falls back to NoSleep.js
        let wakeLock = null;
        let noSleep = null;
        let userHasInteracted = false;

        async function requestWakeLock() {
            const statusDot = document.getElementById('statusDot');
            // Try native Wake Lock API first
            if ('wakeLock' in navigator) {
                try {
                    if (wakeLock) return;
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock released');
                        wakeLock = null;
                        statusDot?.classList.remove('wakelock');
                    });
                    console.log('Wake Lock acquired (native)');
                    statusDot?.classList.add('wakelock');
                    return;
                } catch (e) {
                    console.log('Wake Lock native error:', e.message);
                }
            }
            // Fallback to NoSleep.js (only after user interaction)
            if (noSleep && userHasInteracted) {
                try {
                    await noSleep.enable();
                    console.log('Wake Lock acquired (NoSleep.js)');
                    statusDot?.classList.add('wakelock');
                } catch (e) {
                    console.log('NoSleep.js error:', e.message);
                }
            }
        }

        // Re-acquire when page becomes visible
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') requestWakeLock();
        });

        // Pull-to-refresh - pull down anywhere on game selection screen to hard refresh
        (function() {
            let startY = 0, pulling = false, pullDist = 0;
            const threshold = 120;
            let indicator = null;

            function createIndicator() {
                indicator = document.createElement('div');
                indicator.id = 'pullRefreshIndicator';
                document.body.appendChild(indicator);
            }

            function isGameSelectionScreen() {
                const gameMenu = document.getElementById('gameMenu');
                return gameMenu && gameMenu.style.display !== 'none';
            }

            document.addEventListener('touchstart', e => {
                if (window.scrollY === 0 && isGameSelectionScreen()) {
                    startY = e.touches[0].clientY;
                    pulling = true;
                    pullDist = 0;
                }
            }, { passive: true });

            document.addEventListener('touchmove', e => {
                if (!pulling) return;
                const y = e.touches[0].clientY;
                pullDist = y - startY;
                if (pullDist > 0) {
                    if (!indicator) createIndicator();
                    const progress = Math.min(pullDist / threshold, 1);
                    indicator.style.transform = `translateX(-50%) translateY(${Math.min(pullDist * 0.5, 60) - 40}px)`;
                    indicator.style.opacity = progress;
                }
            }, { passive: true });

            document.addEventListener('touchend', () => {
                if (!pulling) return;
                pulling = false;
                if (indicator) {
                    if (pullDist >= threshold) {
                        indicator.style.transform = 'translateX(-50%) translateY(10px)';
                        indicator.classList.add('spinning');
                        setTimeout(() => location.reload(), 300);
                    } else {
                        indicator.style.transform = 'translateX(-50%) translateY(-50px)';
                        indicator.style.opacity = '0';
                    }
                }
                startY = 0;
                pullDist = 0;
            }, { passive: true });
        })();

        // Console log capture for mobile debugging
        const _logs = [];
        const _maxLogs = 500;
        const _origConsole = { log: console.log, warn: console.warn, error: console.error, info: console.info, debug: console.debug, trace: console.trace };

        function _formatArg(a, seen = new WeakSet()) {
            if (a === null) return 'null';
            if (a === undefined) return 'undefined';
            if (typeof a === 'function') return `[Function: ${a.name || 'anonymous'}]`;
            if (typeof a === 'symbol') return a.toString();
            if (a instanceof Error) {
                return a.stack || `${a.name}: ${a.message}`;
            }
            if (typeof a === 'object') {
                if (seen.has(a)) return '[Circular]';
                seen.add(a);
                try {
                    if (Array.isArray(a)) {
                        return '[' + a.map(x => _formatArg(x, seen)).join(', ') + ']';
                    }
                    const pairs = Object.entries(a).slice(0, 50).map(([k, v]) => `${k}: ${_formatArg(v, seen)}`);
                    return '{' + pairs.join(', ') + (Object.keys(a).length > 50 ? ', ...' : '') + '}';
                } catch { return String(a); }
            }
            return String(a);
        }

        function _captureLog(type, args) {
            const time = new Date().toTimeString().slice(0, 8);
            const msg = Array.from(args).map(a => _formatArg(a)).join(' ');
            _logs.push({ time, type, msg });
            if (_logs.length > _maxLogs) _logs.shift();
        }

        console.log = (...args) => { _captureLog('log', args); _origConsole.log(...args); };
        console.warn = (...args) => { _captureLog('warn', args); _origConsole.warn(...args); };
        console.error = (...args) => { _captureLog('error', args); _origConsole.error(...args); };
        console.info = (...args) => { _captureLog('info', args); _origConsole.info(...args); };
        console.debug = (...args) => { _captureLog('debug', args); _origConsole.debug(...args); };
        console.trace = (...args) => {
            _captureLog('trace', [...args, '\n' + new Error().stack?.split('\n').slice(2).join('\n')]);
            _origConsole.trace(...args);
        };

        // Capture uncaught errors and unhandled promise rejections
        window.addEventListener('error', (e) => {
            const time = new Date().toTimeString().slice(0, 8);
            const msg = e.error?.stack || `${e.message} at ${e.filename}:${e.lineno}:${e.colno}`;
            _logs.push({ time, type: 'error', msg: `[Uncaught] ${msg}` });
            if (_logs.length > _maxLogs) _logs.shift();
        });
        window.addEventListener('unhandledrejection', (e) => {
            const time = new Date().toTimeString().slice(0, 8);
            const reason = e.reason instanceof Error ? (e.reason.stack || e.reason.message) : String(e.reason);
            _logs.push({ time, type: 'error', msg: `[Unhandled Promise] ${reason}` });
            if (_logs.length > _maxLogs) _logs.shift();
        });

        // Debug modal with tabs (Controller Logs | Screen Logs)
        window._receivedScreenLogs = [];
        window._screenDebugMode = false;
        window._updateScreenLogsTab = null;

        function showDebugModal() {
            let modal = document.getElementById('debugModal');
            if (modal) { modal.remove(); window._updateScreenLogsTab = null; return; }
            modal = document.createElement('div');
            modal.id = 'debugModal';
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:100000;display:flex;flex-direction:column;padding:10px;';

            let activeTab = 'controller';
            window._receivedScreenLogs = [];

            let wordWrap = false;

            function renderLogs(logs, emptyMsg) {
                if (!logs || logs.length === 0) return `<div style="color:#666;">${emptyMsg}</div>`;
                const colors = { error: '#f44336', warn: '#FF9800', info: '#2196F3', debug: '#9E9E9E', trace: '#9575CD', log: '#4CAF50' };
                const wrapStyle = wordWrap ? 'word-break:break-all;white-space:pre-wrap;' : 'white-space:pre;';
                return logs.map(l => {
                    const color = colors[l.type] || '#4CAF50';
                    const escaped = l.msg.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>');
                    return `<div style="color:${color};margin:2px 0;${wrapStyle}"><span style="color:#888;">[${l.time}]</span> <span style="color:#666;font-size:10px;">${l.type.toUpperCase()}</span> ${escaped}</div>`;
                }).join('');
            }

            function updateContent() {
                const content = modal.querySelector('#logContent');
                const countSpan = modal.querySelector('#logCount');
                const statusSpan = modal.querySelector('#debugStatus');
                if (activeTab === 'controller') {
                    content.innerHTML = renderLogs(_logs, 'No controller logs yet');
                    countSpan.textContent = _logs.length;
                    statusSpan.textContent = '';
                } else {
                    const logs = window._receivedScreenLogs || [];
                    content.innerHTML = renderLogs(logs, window._screenDebugMode ? 'No screen logs yet' : 'Debug Logs is disabled on screen.\nEnable it in Settings to start capturing.');
                    countSpan.textContent = logs.length;
                    statusSpan.textContent = window._screenDebugMode ? '' : ' (off)';
                }
                content.scrollTop = content.scrollHeight;
            }

            function updateWrapButton() {
                const btn = modal.querySelector('#wrapToggle');
                if (btn) {
                    btn.style.background = wordWrap ? 'rgba(76,175,80,0.3)' : 'rgba(255,255,255,0.1)';
                    btn.style.borderColor = wordWrap ? 'rgba(76,175,80,0.5)' : 'rgba(255,255,255,0.2)';
                    btn.title = wordWrap ? 'Word wrap: ON' : 'Word wrap: OFF';
                }
            }

            window._updateScreenLogsTab = updateContent;

            const tabBase = 'flex:1;padding:10px;border:none;font-size:13px;cursor:pointer;';
            const tabActiveController = tabBase + 'background:#333;border-bottom:2px solid #4CAF50;color:#fff;border-radius:4px 0 0 0;';
            const tabInactiveController = tabBase + 'background:transparent;border-bottom:2px solid transparent;color:#888;border-radius:4px 0 0 0;';
            const tabActiveScreen = tabBase + 'background:#333;border-bottom:2px solid #1AAFFF;color:#fff;border-radius:0 4px 0 0;';
            const tabInactiveScreen = tabBase + 'background:transparent;border-bottom:2px solid transparent;color:#888;border-radius:0 4px 0 0;';

            function setTab(tab) {
                activeTab = tab;
                modal.querySelector('#tabController').style.cssText = tab === 'controller' ? tabActiveController : tabInactiveController;
                modal.querySelector('#tabScreen').style.cssText = tab === 'screen' ? tabActiveScreen : tabInactiveScreen;
                if (tab === 'screen') {
                    // Request screen logs via WebSocket
                    if (typeof wsManager !== 'undefined' && wsManager?.isOpen) {
                        wsManager.send({ type: 'getScreenLogs' });
                    }
                }
                updateContent();
            }

            modal.innerHTML = `
                <div style="color:#fff;font-size:14px;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center;">
                    <span>ðŸ“‹ Logs (<span id="logCount">${_logs.length}</span>)<span id="debugStatus" style="color:#888;font-size:11px;"></span></span>
                    <div style="display:flex;gap:8px;align-items:center;">
                        <button id="wrapToggle" title="Word wrap: OFF" style="width:32px;height:32px;border-radius:4px;border:1px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.1);color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M3 12h15a3 3 0 1 1 0 6h-4l2-2m-2 2l2 2M3 18h7"/></svg>
                        </button>
                        <button onclick="document.getElementById('debugModal').remove();window._updateScreenLogsTab=null;" style="background:#f44336;border:none;color:#fff;padding:8px 16px;border-radius:4px;font-size:14px;">Close</button>
                    </div>
                </div>
                <div style="display:flex;gap:0;margin-bottom:10px;">
                    <button id="tabController" style="${tabActiveController}">Controller</button>
                    <button id="tabScreen" style="${tabInactiveScreen}">Screen</button>
                </div>
                <div id="logContent" style="flex:1;overflow:auto;background:#111;border-radius:4px;padding:8px;font-family:monospace;font-size:11px;user-select:text;-webkit-user-select:text;">
                    ${renderLogs(_logs, 'No controller logs yet')}
                </div>
            `;
            modal.querySelector('#tabController').onclick = () => setTab('controller');
            modal.querySelector('#tabScreen').onclick = () => setTab('screen');
            modal.querySelector('#wrapToggle').onclick = () => { wordWrap = !wordWrap; updateWrapButton(); updateContent(); };
            modal.addEventListener('click', (e) => { if (e.target === modal) { modal.remove(); window._updateScreenLogsTab = null; } });
            document.body.appendChild(modal);
            modal.querySelector('#logContent').scrollTop = 99999;
        }

        // Long-press handler for player status
        let _longPressTimer = null;
        document.addEventListener('DOMContentLoaded', () => {
            const playerStatus = document.getElementById('playerStatus');
            if (!playerStatus) return;
            playerStatus.addEventListener('touchstart', (e) => {
                _longPressTimer = setTimeout(showDebugModal, 1000);
            }, { passive: true });
            playerStatus.addEventListener('touchend', () => clearTimeout(_longPressTimer));
            playerStatus.addEventListener('touchmove', () => clearTimeout(_longPressTimer));
            playerStatus.addEventListener('mousedown', () => {
                _longPressTimer = setTimeout(showDebugModal, 1000);
            });
            playerStatus.addEventListener('mouseup', () => clearTimeout(_longPressTimer));
            playerStatus.addEventListener('mouseleave', () => clearTimeout(_longPressTimer));
        });
    </script>
    <style>
        * { box-sizing: border-box; }
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #1a1a1a; font-family: Arial, sans-serif; position: fixed; top: 0; left: 0; }

        #pullRefreshIndicator {
            position: fixed; top: 0; left: 50%; transform: translateX(-50%) translateY(-50px);
            width: 28px; height: 28px; border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3); border-top-color: #fff;
            z-index: 99999; transition: transform 0.2s, opacity 0.2s;
        }
        #pullRefreshIndicator.spinning { animation: spin 0.6s linear infinite; }
        @keyframes spin { to { transform: translateX(-50%) translateY(10px) rotate(360deg); } }
        #game { position: fixed; inset: 0; width: 100vw; height: 100vh; width: 100dvw; height: 100dvh; }
        .loading { color: #fff; text-align: center; padding: 20px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }

        .player-status { position: fixed; top: 15px; left: 15px; z-index: 9999; display: flex; flex-direction: column; align-items: center; gap: 4px; opacity: 0; transition: opacity 0.3s; }
        .player-status.visible { opacity: 1; }
        .status-dot { position: relative; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: bold; color: #fff; font-family: Arial, sans-serif; transition: all 0.3s; }
        .status-dot.connecting { background: #FF9800; opacity: 0.5; animation: blink 1s ease-in-out infinite; }
        .status-dot.connected { animation: breathe 2s ease-in-out infinite; }
        .status-dot.player-0 { background: #4CAF50; box-shadow: 0 0 15px rgba(76, 175, 80, 0.6); }
        .status-dot.player-1 { background: #2196F3; box-shadow: 0 0 15px rgba(33, 150, 243, 0.6); }
        .status-dot.player-2 { background: #9C27B0; box-shadow: 0 0 15px rgba(156, 39, 176, 0.6); }
        .status-dot.player-3 { background: #FFC107; box-shadow: 0 0 15px rgba(255, 193, 7, 0.6); }
        .status-dot.error { background: #f44336; box-shadow: 0 0 15px rgba(244, 67, 54, 0.6); }
        .status-dot.p2p::after { content: ''; position: absolute; bottom: -1px; right: -1px; width: 6px; height: 6px; background: #9e9d24; border-radius: 50%; transition: background 0.3s; }
        .status-dot.p2p.wakelock::after { background: #4CAF50; }
        @keyframes blink { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
        @keyframes breathe { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.05); opacity: 0.9; } }

        .ping-badge { font-size: 11px; font-family: monospace; font-weight: bold; }
        .ping-badge.ping-good { color: #4CAF50; }
        .ping-badge.ping-ok { color: #FFEB3B; }
        .ping-badge.ping-warn { color: #FF9800; }
        .ping-badge.ping-bad { color: #f44336; }

        .test-controller { position: fixed; top: 15px; right: 65px; z-index: 999; pointer-events: auto; }
        .test-controller.hidden { display: none; }
        .test-controller-toggle { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.25); border-radius: 6px; font-size: 20px; cursor: pointer; transition: all 0.3s; }
        .test-controller-toggle:hover { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.4); transform: scale(1.05); }
        .test-controller.expanded .test-controller-toggle { background: rgba(255, 255, 255, 0.2); border-color: rgba(255, 255, 255, 0.4); }
        .test-controller-links { display: none; flex-direction: column; gap: 6px; margin-top: 8px; padding: 10px; background: rgba(0, 0, 0, 0.9); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; min-width: 180px; position: absolute; right: 0; }
        .test-controller.expanded .test-controller-links { display: flex; }
        .test-controller-link { display: flex; align-items: center; justify-content: center; height: 36px; padding: 0 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #1AAFFF; text-decoration: none; font-size: 12px; white-space: nowrap; transition: all 0.3s; }
        .test-controller-link:hover { background: rgba(255, 255, 255, 0.15); border-color: #1AAFFF; }
    </style>
    <script src="deps/nosleep.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof NoSleep !== 'undefined') {
                noSleep = new NoSleep();
                const enableOnInteraction = () => {
                    userHasInteracted = true;
                    requestWakeLock();
                };
                document.addEventListener('touchstart', enableOnInteraction, { once: true });
                document.addEventListener('click', enableOnInteraction, { once: true });
            }
        });
    </script>
</head>
<body>
    <div id="game"><div class="loading">Mobile Controller</div></div>
    <div class="player-status" id="playerStatus">
        <div class="status-dot" id="statusDot"></div>
        <div class="ping-badge" id="pingBadge"></div>
    </div>
    <div class="test-controller" id="testController">
        <button class="test-controller-toggle" id="testControllerToggle" title="Test Controller">ðŸŽ®</button>
        <div class="test-controller-links">
            <a href="https://hardwaretester.com/gamepad" target="_blank" rel="noopener" class="test-controller-link">hardwaretester.com</a>
            <a href="https://gamepadtester.com/" target="_blank" rel="noopener" class="test-controller-link">gamepadtester.com</a>
        </div>
    </div>
    <game-menu id="gameMenu" mode="controller"></game-menu>

    <script type="module">
        import {
            P2P_PING, P2P_DIGITAL, P2P_ANALOG, P2P_TOGGLE_FPS, P2P_SAVE_STATE,
            P2P_LOAD_STATE, P2P_RESET_MENU, P2P_HARD_REFRESH, P2P_STATE_UPDATE,
            P2P_RTT_ECHO, P2P_STATES, HEARTBEAT_INTERVAL, WebSocketManager,
            IceCandidateBuffer, loadGameMenuComponent
        } from './common.js';

        // ============================================
        // EMULATORJS CONFIG
        // ============================================
        // EmulatorJS config (must use window. prefix in module scope)
        window.EJS_player = '#game';
        window.EJS_pathtodata = 'EmulatorJS/data/';
        window.EJS_controlsOnly = true;
        window.EJS_DEBUG_XX = true;
        window.EJS_disableAutoLang = true;
        window.EJS_language = "en";

        // Button config (base - modified per player in handleGameStarted)
        const buttonConfig = {
            playPause: true, restart: false, mute: true, settings: true, fullscreen: true,
            saveState: false, loadState: false, quickSave: false, quickLoad: false,
            gamepad: true, cheat: false, volume: true, diskButton: false,
            netplay: false, screenRecord: false, saveSavFiles: false, loadSavFiles: false,
            screenshot: false, cacheManager: false, exitEmulation: false,
            toggleFPS: {
                displayName: "FPS",
                icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 24" fill="currentColor"><text x="20" y="18" font-size="24" font-weight="bold" text-anchor="middle" font-family="Arial,sans-serif">FPS</text></svg>',
                callback: () => sendP2PCommand(P2P_TOGGLE_FPS) || sendToScreen({ type: 'toggleFPS' })
            },
            remoteSave: {
                displayName: "Save State",
                icon: '<svg viewBox="0 0 448 512"><path fill="currentColor" d="M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"/></svg>',
                callback: () => sendP2PCommand(P2P_SAVE_STATE, 1) || sendToScreen({ type: 'saveState', slot: 1 })
            },
            remoteLoad: {
                displayName: "Load State",
                icon: '<svg viewBox="0 0 576 512"><path fill="currentColor" d="M572.694 292.093L500.27 416.248A63.997 63.997 0 0 1 444.989 448H45.025c-18.523 0-30.064-20.093-20.731-36.093l72.424-124.155A64 64 0 0 1 152 256h399.964c18.523 0 30.064 20.093 20.73 36.093zM152 224h328v-48c0-26.51-21.49-48-48-48H272l-64-64H48C21.49 64 0 85.49 0 112v278.046l69.077-118.418C86.214 242.25 117.989 224 152 224z"/></svg>',
                callback: () => sendP2PCommand(P2P_LOAD_STATE, 1) || sendToScreen({ type: 'loadState', slot: 1 })
            },
            home: {
                displayName: "Menu",
                icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>',
                callback: () => sendP2PCommand(P2P_RESET_MENU) || sendToScreen({ type: 'resetToMenu' })
            }
        };
        window.EJS_Buttons = buttonConfig;

        // ============================================
        // STATE
        // ============================================
        let wsManager = null;
        // Expose wsManager for debug modal access
        Object.defineProperty(window, 'wsManager', { get: () => wsManager });
        let playerNumber = null;
        let emulatorLoaded = false;
        let currentCore = null;
        let gameMenu = null;

        const urlParams = new URLSearchParams(window.location.search);
        const screenId = urlParams.get('screen');
        const requestedPlayer = urlParams.get('p') ? parseInt(urlParams.get('p'), 10) : null;

        // Generate unique controller ID per session (new tab = new player)
        const controllerId = Array.from(crypto.getRandomValues(new Uint8Array(8)), b => b.toString(16).padStart(2, '0')).join('');

        // ============================================
        // WEBRTC P2P (Zero-allocation hot path)
        // ============================================
        let pc = null, inputChannel = null, currentRtt = 0;
        const iceBuffer = new IceCandidateBuffer();

        // Pre-allocated send buffer (Worker 3 pattern)
        const txBuf = new ArrayBuffer(16);
        const txView = new DataView(txBuf);
        const txBytes = new Uint8Array(txBuf);

        // Pre-allocated button state array (zero-allocation pattern)
        // Buttons 0-23, using 32 for alignment. Value: 0=released, 1=pressed, 255=uninitialized
        const lastButtonState = new Uint8Array(32);
        lastButtonState.fill(255); // Mark all as uninitialized (first message always sends)

        function connectP2P() {
            if (pc) try { pc.close(); } catch {}
            pc = new RTCPeerConnection({ iceServers: [] });
            iceBuffer.reset();

            inputChannel = pc.createDataChannel('input', { ordered: false, maxRetransmitTime: 50 });
            inputChannel.binaryType = 'arraybuffer';

            inputChannel.onopen = () => {
                console.log('[WebRTC] DataChannel open');
                document.getElementById('statusDot').classList.add('p2p');
                lastButtonState.fill(255); // Reset to uninitialized (first message always sends)
            };

            inputChannel.onclose = () => {
                console.log('[WebRTC] DataChannel closed');
                document.getElementById('statusDot').classList.remove('p2p');
            };

            inputChannel.onerror = e => console.error('[WebRTC] DataChannel error:', e);

            inputChannel.onmessage = e => {
                const view = new DataView(e.data);
                const msgType = view.getUint8(0);
                switch (msgType) {
                    case P2P_STATE_UPDATE:
                        handleP2PStateUpdate(new Uint8Array(e.data));
                        return;
                    case P2P_RTT_ECHO:
                        // RTT echo from screen: [msgType:1][timestamp:4]
                        const echoTs = view.getUint32(1, false);
                        currentRtt = ((performance.now() | 0) - echoTs) & 0xFFFF;
                        // Send ping report (methodId=0, rtt in bytes 5-6 as uint16 LE)
                        txView.setUint8(0, P2P_PING);
                        txView.setUint32(1, performance.now() | 0, false);
                        txView.setUint16(5, currentRtt, true);
                        inputChannel.send(new Uint8Array(txBuf, 0, 7));
                        return;
                }
            };

            pc.onicecandidate = e => {
                if (e.candidate) wsManager?.send({ type: 'ice-candidate', candidate: e.candidate });
            };

            pc.onconnectionstatechange = () => {
                console.log('[WebRTC] Connection state:', pc.connectionState);
                if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    document.getElementById('statusDot').classList.remove('p2p');
                }
            };

            pc.createOffer().then(offer => {
                pc.setLocalDescription(offer);
                wsManager?.send({ type: 'webrtc-offer', offer });
                console.log('[WebRTC] Sent offer');
            });
        }

        function handleRemoteAnswer(answer) {
            if (!pc) return;
            pc.setRemoteDescription(answer).then(() => iceBuffer.flush(pc));
        }

        function handleRemoteIceCandidate(candidate) {
            if (!pc) return;
            iceBuffer.add(candidate, pc);
        }

        // P2P stateUpdate decoder
        const textDecoder = new TextDecoder();

        function handleP2PStateUpdate(data) {
            const coreLen = data[3], nameLen = data[4 + coreLen];
            handleStateUpdate({
                type: 'stateUpdate',
                state: P2P_STATES[data[1]] || 'game-selection',
                isPaused: data[2] === 1,
                core: coreLen ? textDecoder.decode(data.subarray(4, 4 + coreLen)) : null,
                gameName: nameLen ? textDecoder.decode(data.subarray(5 + coreLen, 5 + coreLen + nameLen)) : null
            });
        }

        // Analog stick axes (indices 16-23 use 0-0x7fff values)
        const ANALOG_AXES = new Set([16, 17, 18, 19, 20, 21, 22, 23]);

        // Send input over P2P DataChannel. Returns true if sent (or suppressed due to no state change).
        // Protocol: [methodId:1][timestamp:4][button:1][value:1-2]
        function sendP2PInput(button, value, isAnalog) {
            if (!inputChannel || inputChannel.readyState !== 'open') return false;

            // For digital buttons, only send on state change (O(1) array lookup)
            if (!isAnalog) {
                if (lastButtonState[button] === value) {
                    return true; // Already in this state, suppress but don't fallback to WS
                }
                lastButtonState[button] = value;
            }

            txView.setUint32(1, performance.now() | 0, false);
            txBytes[5] = button;

            if (isAnalog) {
                txView.setUint8(0, 2);
                txView.setUint16(6, value & 0xFFFF, true);
                inputChannel.send(new Uint8Array(txBuf, 0, 8));
            } else {
                txView.setUint8(0, 1);
                txBytes[6] = value;
                inputChannel.send(new Uint8Array(txBuf, 0, 7));
            }
            return true;
        }

        // Send P2P command (non-input). Returns true if sent via P2P.
        function sendP2PCommand(methodId, payload = null) {
            if (inputChannel?.readyState !== 'open') return false;
            txBytes[0] = methodId;
            const len = payload !== null ? (txBytes[1] = payload, 2) : 1;
            inputChannel.send(new Uint8Array(txBuf, 0, len));
            return true;
        }

        // ============================================
        // WEBSOCKET
        // ============================================
        function sendToScreen(msg) {
            wsManager?.send(msg);
        }

        function updateStatus(state, playerNum = null, errorMsg = null) {
            const playerStatus = document.getElementById('playerStatus');
            const dot = document.getElementById('statusDot');
            const badge = document.getElementById('pingBadge');
            dot.className = 'status-dot ' + state;
            document.body.className = '';
            if (state === 'connected' && playerNum !== null) {
                dot.classList.add(`player-${playerNum}`);
                dot.textContent = `P${playerNum + 1}`;
                document.body.classList.add('connected', `player-${playerNum}`);
                playerStatus.classList.add('visible');
                badge.textContent = '';
            } else if (state === 'connecting') {
                dot.textContent = '';
                badge.textContent = '';
                playerStatus.classList.add('visible');
            } else if (state === 'error') {
                dot.textContent = 'âœ•';
                if (errorMsg) badge.textContent = errorMsg;
                badge.className = 'ping-badge ping-bad';
                playerStatus.classList.add('visible');
            } else {
                playerStatus.classList.remove('visible');
            }
        }

        function updatePingDisplay(rtt) {
            const badge = document.getElementById('pingBadge');
            badge.textContent = rtt + 'ms';
            badge.className = 'ping-badge';
            if (rtt <= 50) badge.classList.add('ping-good');
            else if (rtt <= 100) badge.classList.add('ping-ok');
            else if (rtt <= 150) badge.classList.add('ping-warn');
            else badge.classList.add('ping-bad');
        }

        function connectWebSocket() {
            if (!screenId) { console.error('No screen ID in URL'); return; }

            updateStatus('connecting');
            wsManager = new WebSocketManager({
                onOpen: () => {
                    console.log('WebSocket connected, registering as controller:', controllerId, 'for screen:', screenId, requestedPlayer !== null ? `(requesting P${requestedPlayer})` : '');
                    const registerMsg = { type: 'register-controller', controllerId, screenId };
                    if (requestedPlayer !== null && requestedPlayer >= 1 && requestedPlayer <= 4) {
                        registerMsg.requestedPlayerNum = requestedPlayer - 1; // Convert to 0-indexed
                    }
                    wsManager.send(registerMsg);
                },
                onMessage: handleMessage,
                onClose: () => {
                    console.log('WebSocket disconnected, reconnecting...');
                    updateStatus('connecting');
                    playerNumber = null;
                },
                onError: err => console.error('WebSocket error:', err)
            });
            wsManager.connect();
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'registered':
                    playerNumber = msg.playerNum;
                    console.log('Controller registered, Player', playerNumber + 1);
                    requestWakeLock(); // Keep phone screen on while connected
                    updateStatus('connected', playerNumber);
                    gameMenu?.setWebSocket(wsManager.ws);
                    updateGameMenuPlayerStatus();
                    connectP2P();
                    break;

                case 'webrtc-answer':
                    handleRemoteAnswer(msg.answer);
                    break;

                case 'ice-candidate':
                    handleRemoteIceCandidate(msg.candidate);
                    break;

                case 'error':
                    console.error('Server error:', msg.error);
                    if (msg.code === 'player-slot-taken') {
                        // Player slot already taken - show message and don't reconnect
                        updateStatus('error', null, `P${msg.requestedPlayer} taken`);
                        wsManager?.disconnect();
                        wsManager = null;
                    }
                    break;

                case 'screen-disconnected':
                    console.log('Screen disconnected');
                    updateStatus('connecting');
                    playerNumber = null;
                    updateGameMenuPlayerStatus();
                    break;

                case 'stateUpdate':
                    handleStateUpdate(msg);
                    break;

                case 'hardRefresh':
                    console.log('Hard refresh requested by screen');
                    window.location.reload();
                    break;

                case 'heartbeat-ack':
                    break;

                case 'settingsSync':
                    // Apply settings from screen to local EmulatorJS instance
                    if (msg.settings && window.window.EJS_emulator?.handler) {
                        console.log('Syncing settings from screen:', Object.keys(msg.settings).length, 'settings');
                        for (const [setting, value] of Object.entries(msg.settings)) {
                            try {
                                window.EJS_emulator.handler.exec('settings.change', { setting, value });
                            } catch (e) { /* ignore individual setting errors */ }
                        }
                    }
                    break;

                case 'menuSettingsSync':
                    // Apply menu settings (gameHeight, threads, debugMode) from screen to game-menu
                    if (msg.settings && gameMenu) {
                        if (msg.settings.gameHeight != null) {
                            gameMenu.applySetting('gameHeight', msg.settings.gameHeight);
                        }
                        if (msg.settings.threads != null) {
                            gameMenu.applySetting('threads', msg.settings.threads);
                        }
                        if (msg.settings.debugMode != null) {
                            gameMenu.applySetting('debugMode', msg.settings.debugMode);
                        }
                        console.log('Menu settings synced from screen:', msg.settings);
                    }
                    break;

                case 'screenLogs':
                    // Received screen logs - store them and update modal if open
                    window._receivedScreenLogs = msg.logs || [];
                    window._screenDebugMode = msg.debugMode;
                    if (typeof window._updateScreenLogsTab === 'function') {
                        window._updateScreenLogsTab();
                    }
                    break;
            }
        }

        connectWebSocket();

        // ============================================
        // PLAYER STATUS
        // ============================================
        function updateGameMenuPlayerStatus() {
            if (!gameMenu) return;
            const players = new Map();
            if (playerNumber !== null) {
                players.set(playerNumber, { connected: true });
            }
            gameMenu.updatePlayerStatus(players);
        }

        // ============================================
        // STATE HANDLERS
        // ============================================
        function handleStateUpdate(data) {
            console.log('State update:', data);
            if (data.state === 'game-ready') handleGameStarted(data.core);
            else if (data.state === 'game-selection') handleGameReset();
            else if (data.state === 'game-pending') {
                gameMenu?.setLoadingText(`Loading ${data.gameName || 'game'}...`);
                gameMenu?.showLoading();
            }
        }

        function handleGameStarted(core) {
            console.log('Game started, core:', core);
            gameMenu?.hide();
            document.getElementById('gameMenu')?.style.setProperty('display', 'none');
            document.getElementById('game').style.display = 'block';
            document.getElementById('testController').classList.add('hidden');

            if (!emulatorLoaded || currentCore !== core) {
                currentCore = core;
                window.EJS_core = core || 'arcade';
                if (emulatorLoaded && window.window.EJS_emulator) {
                    document.getElementById('game').innerHTML = '';
                    window.window.EJS_emulator = null;
                }
                // P1 only: restart and home menu
                const isP1 = playerNumber === 0;
                window.EJS_Buttons = {
                    ...buttonConfig,
                    restart: isP1,
                    home: isP1 ? buttonConfig.home : false
                };
                const script = document.createElement('script');
                script.src = 'EmulatorJS/data/loader.js';
                script.onload = () => {
                    console.log('EmulatorJS loaded');
                    emulatorLoaded = true;
                    // Request settings sync from screen after EmulatorJS is ready
                    setTimeout(() => requestSettingsSync(), 500);
                };
                document.body.appendChild(script);
            }
        }

        function requestSettingsSync() {
            if (wsManager?.isOpen) {
                sendToScreen({ type: 'getSettings' });
                console.log('Requested settings sync from screen');
            }
        }

        function handleGameReset() {
            console.log('Game reset');
            if (window.window.EJS_emulator) try { window.window.EJS_emulator = null; } catch {}
            emulatorLoaded = false;
            currentCore = null;
            document.getElementById('game').innerHTML = '';
            document.getElementById('game').style.display = 'none';
            gameMenu?.show();
            document.getElementById('gameMenu')?.style.setProperty('display', '');
            document.getElementById('testController').classList.remove('hidden');
        }

        // ============================================
        // EMULATORJS CALLBACKS
        // ============================================
        window.EJS_ready = () => console.log('EmulatorJS ready');
        window.EJS_onCommand = event => {
            if (event.method === 'control.fullscreen') return;

            // Handle settings changes - send as explicit setSetting message
            if (event.method === 'settings.change' && event.params) {
                console.log('Setting changed locally:', event.params.setting, '=', event.params.value);
                sendToScreen({ type: 'setSetting', setting: event.params.setting, value: event.params.value });
                return;
            }

            if (event.method === 'input.simulate' && event.params) {
                const { button, state, value } = event.params;
                const isAnalog = state === 'analog' || ANALOG_AXES.has(button);
                const inputValue = isAnalog ? (value || 0) : (state === 'pressed' || value === 1 ? 1 : 0);

                if (sendP2PInput(button, inputValue, isAnalog)) return;

                // WebSocket fallback: also deduplicate (O(1) array lookup)
                if (!isAnalog) {
                    if (lastButtonState[button] === inputValue) return;
                    lastButtonState[button] = inputValue;
                }

                event.params.player = playerNumber ?? 0;
            }
            sendToScreen(event);
        };

        // ============================================
        // GAME MENU
        // ============================================
        // Hide game div immediately - game-menu element is already in HTML
        document.getElementById('game').style.display = 'none';

        (async () => {
            gameMenu = await loadGameMenuComponent();
            if (gameMenu && wsManager?.isOpen) {
                gameMenu.setWebSocket(wsManager.ws);
                updateGameMenuPlayerStatus();
            }
            // Forward setting changes to screen via WebSocket
            gameMenu?.addEventListener('settingchange', (e) => {
                const { setting, value } = e.detail;
                console.log('Setting changed on controller:', setting, '=', value);
                sendToScreen({ type: 'menuSetting', setting, value });
            });
        })();

        window.addEventListener('beforeunload', () => {
            if (pc) try { pc.close(); } catch {}
            wsManager?.disconnect();
        });

        document.getElementById('testControllerToggle').onclick = () => {
            document.getElementById('testController').classList.toggle('expanded');
        };
    </script>
</body>
</html>
