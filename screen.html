<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroBox</title>
    <script>
        // Disable WakeLock by intercepting errors
        const originalRequest = navigator.wakeLock?.request;
        if (originalRequest) {
            navigator.wakeLock.request = async function(...args) {
                try { return await originalRequest.apply(this, args); }
                catch (e) {
                    console.log('WakeLock error caught:', e.message);
                    return { released: false, type: args[0], release: async () => {}, addEventListener: () => {}, removeEventListener: () => {} };
                }
            };
        }

        // Console log capture for debug mode (screen logs sent to controller)
        const _screenLogs = [];
        const _maxScreenLogs = 500;
        let _debugModeEnabled = localStorage.getItem('retrobox_debugMode') === 'true';
        const _origScreenConsole = { log: console.log, warn: console.warn, error: console.error, info: console.info, debug: console.debug, trace: console.trace };

        function _formatArg(a, seen = new WeakSet()) {
            if (a === null) return 'null';
            if (a === undefined) return 'undefined';
            if (typeof a === 'function') return `[Function: ${a.name || 'anonymous'}]`;
            if (typeof a === 'symbol') return a.toString();
            if (a instanceof Error) {
                return a.stack || `${a.name}: ${a.message}`;
            }
            if (typeof a === 'object') {
                if (seen.has(a)) return '[Circular]';
                seen.add(a);
                try {
                    if (Array.isArray(a)) {
                        return '[' + a.map(x => _formatArg(x, seen)).join(', ') + ']';
                    }
                    const pairs = Object.entries(a).slice(0, 50).map(([k, v]) => `${k}: ${_formatArg(v, seen)}`);
                    return '{' + pairs.join(', ') + (Object.keys(a).length > 50 ? ', ...' : '') + '}';
                } catch { return String(a); }
            }
            return String(a);
        }

        function _captureScreenLog(type, args) {
            if (!_debugModeEnabled) return;
            const time = new Date().toTimeString().slice(0, 8);
            const msg = Array.from(args).map(a => _formatArg(a)).join(' ');
            _screenLogs.push({ time, type, msg });
            if (_screenLogs.length > _maxScreenLogs) _screenLogs.shift();
        }

        console.log = (...args) => { _captureScreenLog('log', args); _origScreenConsole.log(...args); };
        console.warn = (...args) => { _captureScreenLog('warn', args); _origScreenConsole.warn(...args); };
        console.error = (...args) => { _captureScreenLog('error', args); _origScreenConsole.error(...args); };
        console.info = (...args) => { _captureScreenLog('info', args); _origScreenConsole.info(...args); };
        console.debug = (...args) => { _captureScreenLog('debug', args); _origScreenConsole.debug(...args); };
        console.trace = (...args) => {
            _captureScreenLog('trace', [...args, '\n' + new Error().stack?.split('\n').slice(2).join('\n')]);
            _origScreenConsole.trace(...args);
        };

        // Capture uncaught errors and unhandled promise rejections
        window.addEventListener('error', (e) => {
            if (!_debugModeEnabled) return;
            const time = new Date().toTimeString().slice(0, 8);
            const msg = e.error?.stack || `${e.message} at ${e.filename}:${e.lineno}:${e.colno}`;
            _screenLogs.push({ time, type: 'error', msg: `[Uncaught] ${msg}` });
            if (_screenLogs.length > _maxScreenLogs) _screenLogs.shift();
        });
        window.addEventListener('unhandledrejection', (e) => {
            if (!_debugModeEnabled) return;
            const time = new Date().toTimeString().slice(0, 8);
            const reason = e.reason instanceof Error ? (e.reason.stack || e.reason.message) : String(e.reason);
            _screenLogs.push({ time, type: 'error', msg: `[Unhandled Promise] ${reason}` });
            if (_screenLogs.length > _maxScreenLogs) _screenLogs.shift();
        });

        function _setDebugMode(enabled) {
            _debugModeEnabled = enabled;
            if (!enabled) _screenLogs.length = 0; // Clear buffer when disabled
        }
        function _getScreenLogs() { return _screenLogs.slice(); }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #1a1a1a; font-family: Arial, sans-serif; }
        body { display: flex; justify-content: center; align-items: center; }
        .game-container { width: 100%; height: 100%; border-radius: 8px; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; }
        #game { width: 100%; height: 100%; }

        #loadingOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .loading { color: #fff; text-align: center; padding: 20px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; z-index: 100; }
        .loading-spinner { margin: 20px auto; width: 50px; height: 50px; border: 3px solid rgba(255, 255, 255, 0.3); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .controllers { position: fixed; top: max(10px, 1.5vh); right: max(10px, 1.5vw); z-index: 1000; display: flex; gap: max(4px, 0.8vmin); }
        .controller-dot { width: max(6px, 1vmin); height: max(6px, 1vmin); border-radius: 50%; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15); transition: all 0.3s; position: relative; }
        .controller-dot.active { width: max(10px, 1.5vmin); height: max(10px, 1.5vmin); border: none; animation: pulse 2s ease-in-out infinite; }
        .controller-dot.active.player-0 { background: #4CAF50; box-shadow: 0 0 max(6px, 1vmin) rgba(76, 175, 80, 0.5); }
        .controller-dot.active.player-1 { background: #2196F3; box-shadow: 0 0 max(6px, 1vmin) rgba(33, 150, 243, 0.5); }
        .controller-dot.active.player-2 { background: #9C27B0; box-shadow: 0 0 max(6px, 1vmin) rgba(156, 39, 176, 0.5); }
        .controller-dot.active.player-3 { background: #FFC107; box-shadow: 0 0 max(6px, 1vmin) rgba(255, 193, 7, 0.5); }
        .controller-dot.reserved { width: max(8px, 1.2vmin); height: max(8px, 1.2vmin); opacity: 0.4; animation: none; }
        .controller-dot.reserved.player-0 { background: #4CAF50; }
        .controller-dot.reserved.player-1 { background: #2196F3; }
        .controller-dot.reserved.player-2 { background: #9C27B0; }
        .controller-dot.reserved.player-3 { background: #FFC107; }
        .controller-dot .ping { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); font-size: 8px; color: rgba(255,255,255,0.5); white-space: nowrap; margin-top: 2px; font-family: monospace; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.8; } }

        .qr-container { position: fixed; top: 20px; left: 20px; z-index: 999; text-align: center; background: rgba(0, 0, 0, 0.9); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); transition: opacity 0.3s, transform 0.3s, z-index 0s; display: flex; flex-direction: column; align-items: center; cursor: pointer; }
        .qr-container.hidden { opacity: 0; transform: translateY(-20px); pointer-events: none; }
        .qr-container.front { z-index: 1002; }
        .qr-code-display { background: white; padding: 10px; border-radius: 4px; display: inline-block; margin: 5px 0; }
        .qr-code-display img, .qr-code-display canvas { display: block; width: 100% !important; height: 100% !important; }
        .qr-text { color: rgba(255, 255, 255, 0.8); font-size: max(12px, min(2.5vw, 2.5vh)); margin-bottom: 8px; font-weight: 500; }
        .qr-url { color: #4a9eff; font-family: monospace; margin-top: 8px; word-break: break-all; text-decoration: none; transition: color 0.2s; display: block; text-align: center; line-height: 1.3; }
        .qr-url:hover { color: #7bc0ff; text-decoration: underline; }

        .status { position: fixed; bottom: max(8px, 1.5vh); right: max(8px, 1.5vw); padding: max(4px, 0.8vmin) max(8px, 1.5vmin); border-radius: max(3px, 0.5vmin); font-size: max(10px, min(2vw, 2vh, 14px)); z-index: 1001; transition: opacity 0.3s, visibility 0.3s; opacity: 0.7; }
        .status.hidden { opacity: 0; visibility: hidden; }
        .status.connecting { background: #FF9800; color: #000; }
        .status.connected { background: #4CAF50; color: #fff; }
        .status.error { background: #f44336; color: #fff; }

        #audioMutedIndicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.9); color: white; padding: 12px 24px; border-radius: 8px; font-size: 16px; z-index: 3000; cursor: pointer; display: none; align-items: center; gap: 10px; border: 1px solid rgba(255, 255, 255, 0.2); }
        #audioMutedIndicator.visible { display: flex; }
        #audioMutedIndicator .icon { font-size: 24px; }
        #audioMutedIndicator .hint { font-size: 12px; opacity: 0.6; }

        #pauseOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.4); z-index: 998; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #pauseOverlay.visible { opacity: 1; }

    </style>
</head>
<body>
    <div class="qr-container" id="qrContainer">
        <div class="qr-text">Scan to connect</div>
        <div class="qr-code-display" id="qrCodeDisplay"></div>
        <a class="qr-url" id="qrUrl" href="#" target="_blank" rel="noopener"></a>
    </div>
    <div class="game-container"><div id="game"></div></div>
    <div id="loadingOverlay"><div class="loading"><div class="loading-spinner"></div></div></div>
    <div id="audioMutedIndicator">
        <span class="icon">ðŸ”‡</span>
        <div><div class="text">Audio muted</div><div class="hint">Press any key or tap to enable</div></div>
    </div>
    <div class="controllers" id="controllers"></div>
    <div class="status connecting" id="status">Connecting...</div>
    <div id="pauseOverlay"></div>
    <game-menu id="gameMenu" mode="screen"></game-menu>

    <script type="module">
        import {
            P2P_PING, P2P_DIGITAL, P2P_ANALOG, P2P_TOGGLE_FPS, P2P_SAVE_STATE,
            P2P_LOAD_STATE, P2P_RESET_MENU, P2P_HARD_REFRESH, P2P_STATE_UPDATE,
            P2P_RTT_ECHO, P2P_INPUT_SNAPSHOT, P2P_STATES, WebSocketManager,
            IceCandidateBuffer, loadGameMenuComponent, isSeqNewer
        } from './common.js?v=20260206';

        // ============================================
        // CONSTANTS
        // ============================================
        const GRACE_PERIOD = 7500;

        // ============================================
        // STATE
        // ============================================
        const State = { IDLE: 'game-selection', LOADING: 'game-pending', PLAYING: 'game-ready' };
        let currentState = State.IDLE;
        let pendingROM = null;
        let isPaused = false;
        let gameMenu = null;

        let wsManager = null;
        let screenId = null;
        let loaderScript = null; // Track the loader script element
        let wakeLock = null; // Wake lock to prevent screen off when controller connected
        let ejsScriptsLoaded = false; // Track if EmulatorJS scripts have been loaded (can't be unloaded)

        // Wake lock management
        async function acquireWakeLock() {
            if (wakeLock) return; // Already held
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake lock acquired - screen will stay on');
                wakeLock.addEventListener('release', () => {
                    console.log('Wake lock released');
                    wakeLock = null;
                });
            } catch (e) {
                console.log('Wake lock request failed:', e.message);
            }
        }

        async function releaseWakeLock() {
            if (!wakeLock) return;
            try {
                await wakeLock.release();
                wakeLock = null;
                console.log('Wake lock manually released');
            } catch (e) {
                console.log('Wake lock release failed:', e.message);
            }
        }

        // ============================================
        // WEBRTC P2P STATE
        // ============================================
        const peers = new Map(); // controllerId -> { pc, reliableChannel, fastChannel, legacyChannel, playerNum, rtt, iceBuffer, lastDigitalSeq, lastAnalogSeq, lastSnapshotSeq, digitalMask }
        const pendingRemoval = new Map(); // controllerId -> timeout
        const ANALOG_AXES = new Set([16, 17, 18, 19, 20, 21, 22, 23]);
        const P2P_PING_UI_UPDATE_MS = 350;
        // Pre-allocated echo buffer: [messageType:1][timestamp:4] = 5 bytes
        const echoBuf = new ArrayBuffer(5);
        const echoView = new DataView(echoBuf);

        // P2P stateUpdate sender
        const stateUpdateBuf = new ArrayBuffer(256);
        const stateUpdateBytes = new Uint8Array(stateUpdateBuf);
        const textEncoder = new TextEncoder();

        function getPeerReliableChannel(peer) {
            if (peer?.reliableChannel?.readyState === 'open') return peer.reliableChannel;
            if (peer?.legacyChannel?.readyState === 'open') return peer.legacyChannel;
            return null;
        }

        function getPeerStateChannel(peer) {
            return getPeerReliableChannel(peer) || (peer?.fastChannel?.readyState === 'open' ? peer.fastChannel : null);
        }

        function sendP2PStateUpdate(peer, stateEnum, isPaused, core, gameName) {
            const channel = getPeerStateChannel(peer);
            if (!channel) return false;
            let o = 0;
            stateUpdateBytes[o++] = P2P_STATE_UPDATE;
            stateUpdateBytes[o++] = stateEnum;
            stateUpdateBytes[o++] = isPaused ? 1 : 0;
            const coreBytes = core ? textEncoder.encode(core) : null;
            stateUpdateBytes[o++] = coreBytes?.length || 0;
            if (coreBytes) { stateUpdateBytes.set(coreBytes, o); o += coreBytes.length; }
            const nameBytes = gameName ? textEncoder.encode(gameName) : null;
            stateUpdateBytes[o++] = nameBytes?.length || 0;
            if (nameBytes) { stateUpdateBytes.set(nameBytes, o); o += nameBytes.length; }
            channel.send(new Uint8Array(stateUpdateBuf, 0, o));
            return true;
        }

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        function getStateInfo() {
            return { type: 'stateUpdate', state: currentState, gameName: pendingROM?.name, core: pendingROM?.core, isPaused };
        }

        function setState(newState) {
            if (currentState === newState) return;
            console.log(`State: ${currentState} -> ${newState}`);
            currentState = newState;
            updateScreenUI();
            broadcastToControllers(getStateInfo());
        }

        function broadcastToControllers(msg) {
            // Send stateUpdate via P2P for low latency
            if (msg.type === 'stateUpdate') {
                const stateEnum = P2P_STATES.indexOf(msg.state);
                for (const [, peer] of peers) {
                    sendP2PStateUpdate(peer, stateEnum >= 0 ? stateEnum : 0, msg.isPaused, msg.core, msg.gameName);
                }
            }
            // Always also send via WS (fallback for controllers without P2P)
            wsManager?.send(msg);
        }

        function updateScreenUI() {
            switch (currentState) {
                case State.IDLE:
                    gameMenu?.show(); hidePauseOverlay(); showQRCode(); showStatus(); break;
                case State.LOADING:
                    gameMenu?.setLoadingText(`Loading ${pendingROM?.name || 'game'}...`);
                    gameMenu?.showLoading(); hidePauseOverlay(); hideQRCode(); hideStatus(); break;
                case State.PLAYING:
                    gameMenu?.hide(); hideStatus();
                    if (isPaused) { showPauseOverlay(); showQRCode(); } else { hidePauseOverlay(); hideQRCode(); }
                    break;
            }
        }

        function showStatus() { document.getElementById('status').classList.remove('hidden'); }
        function hideStatus() { document.getElementById('status').classList.add('hidden'); }

        // ============================================
        // PAUSE
        // ============================================
        function syncPauseUI(paused) {
            if (currentState !== State.PLAYING) return;
            isPaused = paused;
            if (isPaused) { showPauseOverlay(); showQRCode(); } else { hidePauseOverlay(); hideQRCode(); }
            broadcastToControllers(getStateInfo());
        }

        function setPause(paused) {
            if (currentState !== State.PLAYING || isPaused === paused) return;
            if (paused) window.EJS_emulator?.pause?.(); else window.EJS_emulator?.play?.();
            syncPauseUI(paused);
        }

        function showPauseOverlay() { document.getElementById('pauseOverlay').classList.add('visible'); }
        function hidePauseOverlay() { document.getElementById('pauseOverlay').classList.remove('visible'); }

        // ============================================
        // WEBSOCKET
        // ============================================
        function updateStatus(status, text) {
            const el = document.getElementById('status');
            el.className = 'status ' + status;
            el.textContent = text;
        }

        function connectWebSocket() {
            updateStatus('connecting', 'Connecting...');
            wsManager = new WebSocketManager({
                onOpen: () => {
                    console.log('WebSocket connected, registering as screen:', screenId);
                    wsManager.send({ type: 'register-screen', screenId });
                },
                onMessage: handleMessage,
                onClose: () => {
                    console.log('WebSocket disconnected, reconnecting...');
                    updateStatus('connecting', 'Reconnecting...');
                },
                onError: err => {
                    console.error('WebSocket error:', err);
                    updateStatus('error', 'Connection error');
                }
            });
            wsManager.connect();
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'registered':
                    console.log('Screen registered:', msg.screenId);
                    updateStatus('connected', 'Ready: ' + screenId);
                    break;

                case 'controller-connected':
                    handleControllerConnected(msg.controllerId, msg.playerNum);
                    break;

                case 'controller-disconnected':
                    handleControllerDisconnected(msg.controllerId, msg.playerNum);
                    break;

                case 'webrtc-offer':
                    handleWebRTCOffer(msg.from, msg.offer);
                    break;

                case 'ice-candidate':
                    handleRemoteIceCandidate(msg.from, msg.candidate);
                    break;

                case 'heartbeat-ack':
                    break;

                case 'startGame':
                    if (msg.gameData) loadROM(msg.gameData);
                    break;

                case 'resetToMenu':
                    resetToGameMenu();
                    break;

                case 'hardRefresh':
                    console.log('Hard refresh requested by controller');
                    window.location.reload();
                    break;

                case 'toggleFPS':
                    toggleFPS();
                    break;

                case 'saveState':
                    saveState(msg.slot);
                    break;

                case 'loadState':
                    loadState(msg.slot);
                    break;

                case 'setSetting':
                    // Apply setting from controller
                    if (window.EJS_emulator?.handler && msg.setting) {
                        try {
                            window.EJS_emulator.handler.exec('settings.change', { setting: msg.setting, value: msg.value });
                            console.log('Setting applied from controller:', msg.setting, '=', msg.value);
                        } catch (e) { console.error('Setting error:', e); }
                    }
                    break;

                case 'getSettings':
                    // Send current settings to requesting controller (server adds controllerId to msg)
                    if (window.EJS_emulator?.settings && msg.controllerId) {
                        wsManager?.send({
                            type: 'settingsSync',
                            targetController: msg.controllerId,
                            settings: window.EJS_emulator.settings,
                            core: pendingROM?.core
                        });
                        console.log('Sent settings sync to controller:', msg.controllerId);
                    }
                    break;

                case 'menuSetting':
                    // Apply menu setting from controller (gameHeight, threads, debugMode) and persist
                    if (msg.setting && gameMenu) {
                        gameMenu.applySetting(msg.setting, msg.value);
                        console.log('Menu setting applied from controller:', msg.setting, '=', msg.value);
                        // Update debug mode state for log buffering
                        if (msg.setting === 'debugMode') {
                            _setDebugMode(msg.value === true || msg.value === 'true');
                        }
                    }
                    break;

                case 'getScreenLogs':
                    // Send screen logs to requesting controller
                    if (msg.controllerId) {
                        wsManager?.send({
                            type: 'screenLogs',
                            targetController: msg.controllerId,
                            logs: _getScreenLogs(),
                            debugMode: _debugModeEnabled
                        });
                        console.log('Sent screen logs to controller:', msg.controllerId, '(' + _getScreenLogs().length + ' logs)');
                    }
                    break;

                default:
                    // Handle input and other commands from controller (WebSocket fallback)
                    if (currentState === State.PLAYING && window.EJS_emulator?.handler && msg.method) {
                        try {
                            window.EJS_emulator.handler.exec(msg.method, msg.params);
                            // Log non-input commands for debugging
                            if (msg.method !== 'input.simulate') {
                                console.log('Command from controller:', msg.method, msg.params);
                            }
                        }
                        catch (e) { console.error('Command error:', e); }
                    }
            }
        }

        // ============================================
        // WEBRTC P2P (Screen side)
        // ============================================
        function createPeerState(playerNum) {
            return {
                pc: null,
                reliableChannel: null,
                fastChannel: null,
                legacyChannel: null,
                playerNum,
                rtt: 0,
                iceBuffer: new IceCandidateBuffer(),
                lastDigitalSeq: null,
                lastAnalogSeq: null,
                lastSnapshotSeq: null,
                digitalMask: 0,
                lastPingUiUpdateAt: 0
            };
        }

        function handleControllerConnected(controllerId, playerNum) {
            console.log('Controller connected:', controllerId, 'Player', playerNum + 1);

            // Cancel pending removal if reconnecting
            if (pendingRemoval.has(controllerId)) {
                clearTimeout(pendingRemoval.get(controllerId));
                pendingRemoval.delete(controllerId);
                console.log('[WebRTC] Reconnection within grace period, restored Player', playerNum + 1);
            }

            // Track peer (P2P connection created on offer)
            if (!peers.has(controllerId)) {
                peers.set(controllerId, createPeerState(playerNum));
            } else {
                peers.get(controllerId).playerNum = playerNum;
            }

            // Acquire wake lock when controller connects
            acquireWakeLock();

            updateControllerDisplay();
            wsManager?.send({ ...getStateInfo(), targetController: controllerId });

            // Send current menu settings to the newly connected controller
            const gameHeight = parseInt(localStorage.getItem('retrobox_gameHeight') || '100');
            const threads = localStorage.getItem('retrobox_threads') === 'true';
            const debugMode = localStorage.getItem('retrobox_debugMode') === 'true';
            const loadOnStart = localStorage.getItem('retrobox_loadOnStart') === 'true';
            wsManager?.send({
                type: 'menuSettingsSync',
                targetController: controllerId,
                settings: { gameHeight, threads, debugMode, loadOnStart }
            });
        }

        function handleControllerDisconnected(controllerId, playerNum) {
            console.log('Controller disconnected:', controllerId, 'Player', playerNum + 1);

            // Start grace period for reconnection
            const timeout = setTimeout(() => {
                console.log('[WebRTC] Grace period expired for Player', playerNum + 1);
                const peer = peers.get(controllerId);
                if (peer?.pc) try { peer.pc.close(); } catch {}
                peers.delete(controllerId);
                pendingRemoval.delete(controllerId);
                updateControllerDisplay();


                // Release wake lock when no controllers connected
                if (peers.size === 0) {
                    releaseWakeLock();
                }
                // Auto-pause when no controllers
                if (peers.size === 0 && currentState === State.PLAYING && !isPaused) {
                    console.log('No controllers, pausing...');
                    setPause(true);
                }
            }, GRACE_PERIOD);

            pendingRemoval.set(controllerId, timeout);
            updateControllerDisplay();
        }

        function getNextPlayerNum() {
            const used = new Set([...peers.values()].map(p => p.playerNum));
            for (let i = 0; i < 4; i++) if (!used.has(i)) return i;
            return peers.size;
        }

        function attachPeerChannel(controllerId, peer, channel) {
            const label = channel.label || 'input-legacy';
            channel.binaryType = 'arraybuffer';
            if (label === 'input-reliable') peer.reliableChannel = channel;
            else if (label === 'input-fast') peer.fastChannel = channel;
            else peer.legacyChannel = channel;

            channel.onopen = () => {
                console.log('[WebRTC] DataChannel open:', controllerId, label);
            };
            channel.onmessage = evt => handleP2PMessage(controllerId, evt.data);
            channel.onclose = () => {
                if (peer.reliableChannel === channel) peer.reliableChannel = null;
                if (peer.fastChannel === channel) peer.fastChannel = null;
                if (peer.legacyChannel === channel) peer.legacyChannel = null;
                console.log('[WebRTC] DataChannel closed:', controllerId, label);
            };
            channel.onerror = err => console.error('[WebRTC] DataChannel error:', controllerId, label, err);
        }

        function sendRttEcho(peer, timestamp) {
            const channel = getPeerReliableChannel(peer) || (peer?.fastChannel?.readyState === 'open' ? peer.fastChannel : null);
            if (!channel) return;
            echoView.setUint8(0, P2P_RTT_ECHO);
            echoView.setUint32(1, timestamp, false);
            channel.send(echoBuf);
        }

        function applyDigitalInput(peer, button, value) {
            if (button < 0 || button >= 32) return;
            if (!ANALOG_AXES.has(button)) {
                if (value === 1) peer.digitalMask = (peer.digitalMask | (1 << button)) >>> 0;
                else peer.digitalMask = (peer.digitalMask & ~(1 << button)) >>> 0;
            }
            if (currentState !== State.PLAYING || !window.EJS_emulator?.handler) return;
            const player = peer?.playerNum ?? 0;
            const state = value === 1 ? 'pressed' : 'released';
            try {
                window.EJS_emulator.handler.exec('input.simulate', { button, player, state, value });
            } catch (e) {
                console.error('P2P digital input error:', e);
            }
        }

        function applyAnalogInput(peer, button, value) {
            if (button < 0 || button >= 32) return;
            if (currentState !== State.PLAYING || !window.EJS_emulator?.handler) return;
            const player = peer?.playerNum ?? 0;
            try {
                window.EJS_emulator.handler.exec('input.simulate', { button, player, state: 'analog', value });
            } catch (e) {
                console.error('P2P analog input error:', e);
            }
        }

        function applyDigitalSnapshot(peer, view) {
            if (view.byteLength < 7) return;
            const seq = view.getUint16(1, true);
            if (!isSeqNewer(seq, peer.lastSnapshotSeq)) return;
            peer.lastSnapshotSeq = seq;

            const mask = view.getUint32(3, true) >>> 0;
            const changed = (peer.digitalMask ^ mask) >>> 0;
            peer.digitalMask = mask;
            if (!changed) return;
            if (currentState !== State.PLAYING || !window.EJS_emulator?.handler) return;

            const player = peer?.playerNum ?? 0;
            for (let i = 0; i < 32; i++) {
                const bit = (1 << i) >>> 0;
                if ((changed & bit) === 0) continue;
                if (ANALOG_AXES.has(i)) continue;
                const pressed = (mask & bit) !== 0;
                try {
                    window.EJS_emulator.handler.exec('input.simulate', {
                        button: i,
                        player,
                        state: pressed ? 'pressed' : 'released',
                        value: pressed ? 1 : 0
                    });
                } catch (e) {
                    console.error('P2P snapshot apply error:', e);
                }
            }
        }

        function handleWebRTCOffer(controllerId, offer) {
            console.log('[WebRTC] Received offer from:', controllerId);
            let peer = peers.get(controllerId);
            if (!peer) {
                peer = createPeerState(getNextPlayerNum());
                peers.set(controllerId, peer);
            }

            // Close existing connection if any
            if (peer.pc) try { peer.pc.close(); } catch {}
            peer.iceBuffer.reset();
            peer.reliableChannel = null;
            peer.fastChannel = null;
            peer.legacyChannel = null;
            peer.lastDigitalSeq = null;
            peer.lastAnalogSeq = null;
            peer.lastSnapshotSeq = null;
            peer.digitalMask = 0;

            const pc = new RTCPeerConnection({ iceServers: [] });
            peer.pc = pc;

            pc.ondatachannel = e => {
                console.log('[WebRTC] DataChannel received from:', controllerId, e.channel.label || 'input-legacy');
                attachPeerChannel(controllerId, peer, e.channel);
            };

            pc.onicecandidate = e => {
                if (e.candidate) wsManager?.send({ type: 'ice-candidate', to: controllerId, candidate: e.candidate });
            };

            pc.onconnectionstatechange = () => {
                console.log('[WebRTC] Connection state:', controllerId, pc.connectionState);
            };

            pc.setRemoteDescription(offer).then(() => {
                peer.iceBuffer.flush(pc);
                return pc.createAnswer();
            }).then(answer => {
                return pc.setLocalDescription(answer);
            }).then(() => {
                if (peer.pc !== pc || !pc.localDescription) return;
                wsManager?.send({ type: 'webrtc-answer', to: controllerId, answer: pc.localDescription });
                console.log('[WebRTC] Sent answer to:', controllerId);
            }).catch(err => {
                console.error('[WebRTC] Offer handling error:', controllerId, err);
            });
        }

        function handleRemoteIceCandidate(controllerId, candidate) {
            const peer = peers.get(controllerId);
            if (!peer?.pc) return;
            peer.iceBuffer.add(candidate, peer.pc);
        }

        function handleP2PMessage(controllerId, data) {
            const view = new DataView(data);
            const methodId = view.getUint8(0);
            const peer = peers.get(controllerId);
            if (!peer) return;

            switch (methodId) {
                case P2P_PING:
                    if (view.byteLength >= 7) peer.rtt = view.getUint16(5, true);
                    const now = performance.now();
                    if (!peer.lastPingUiUpdateAt || (now - peer.lastPingUiUpdateAt) >= P2P_PING_UI_UPDATE_MS) {
                        peer.lastPingUiUpdateAt = now;
                        updateControllerDisplay();
                    }
                    if (view.byteLength >= 5) sendRttEcho(peer, view.getUint32(1, false));
                    return;
                case P2P_INPUT_SNAPSHOT:
                    applyDigitalSnapshot(peer, view);
                    return;
                case P2P_TOGGLE_FPS: toggleFPS(); return;
                case P2P_SAVE_STATE: saveState(view.byteLength > 1 ? view.getUint8(1) : 1); return;
                case P2P_LOAD_STATE: loadState(view.byteLength > 1 ? view.getUint8(1) : 1); return;
                case P2P_RESET_MENU: resetToGameMenu(); return;
                case P2P_HARD_REFRESH: window.location.reload(); return;
                case P2P_DIGITAL:
                case P2P_ANALOG:
                    break; // Fall through to input handling
                default:
                    return; // Unknown method
            }

            if (methodId === P2P_DIGITAL) {
                let button;
                let value;
                if (view.byteLength >= 9) {
                    const seq = view.getUint16(5, true);
                    if (!isSeqNewer(seq, peer.lastDigitalSeq)) return;
                    peer.lastDigitalSeq = seq;
                    button = view.getUint8(7);
                    value = view.getUint8(8);
                } else if (view.byteLength >= 7) {
                    // Backward-compatible decode for older controllers.
                    button = view.getUint8(5);
                    value = view.getUint8(6);
                } else {
                    return;
                }
                applyDigitalInput(peer, button, value);
                return;
            }

            if (methodId === P2P_ANALOG) {
                let button;
                let value;
                if (view.byteLength >= 10) {
                    const seq = view.getUint16(5, true);
                    if (!isSeqNewer(seq, peer.lastAnalogSeq)) return;
                    peer.lastAnalogSeq = seq;
                    button = view.getUint8(7);
                    value = view.getUint16(8, true);
                } else if (view.byteLength >= 8) {
                    // Backward-compatible decode for older controllers.
                    button = view.getUint8(5);
                    value = view.getUint16(6, true);
                } else {
                    return;
                }
                applyAnalogInput(peer, button, value);
            }
        }

        function updateControllerDisplay() {
            const container = document.getElementById('controllers');
            container.innerHTML = '';

            // Build player map from peers
            const playerMap = new Map();
            for (const [id, peer] of peers) {
                const isReserved = pendingRemoval.has(id);
                playerMap.set(peer.playerNum, { connected: !isReserved, reserved: isReserved, rtt: peer.rtt });
            }

            for (let i = 0; i < 4; i++) {
                const info = playerMap.get(i);

                // Top-right corner dots with ping
                const dot = document.createElement('div');
                dot.className = 'controller-dot';
                if (info) {
                    dot.classList.add(info.connected ? 'active' : 'reserved', `player-${i}`);
                    if (info.connected && info.rtt > 0) {
                        const ping = document.createElement('span');
                        ping.className = 'ping';
                        ping.textContent = info.rtt + 'ms';
                        dot.appendChild(ping);
                    }
                }
                container.appendChild(dot);
            }

            // Update game menu player status
            gameMenu?.updatePlayerStatus(playerMap);
        }

        // Initialize
        async function init() {
            const urlParams = new URLSearchParams(window.location.search);
            const isE2E = urlParams.has('e2e');
            
            if (urlParams.get('host')) {
                screenId = urlParams.get('host').replace(/\./g, '-');
            } else if (isE2E) {
                // E2E tests use a unique random screenId to avoid conflicts with production kiosk
                screenId = 'e2e-' + Array.from(crypto.getRandomValues(new Uint8Array(4)), b => b.toString(16).padStart(2, '0')).join('');
            } else {
                try {
                    const res = await fetch('/api/client-hostname');
                    const data = await res.json();
                    screenId = (data.hostname || data.ip || 'unknown').replace(/\./g, '-');
                } catch (e) {
                    console.warn('Could not fetch hostname, using random ID');
                    screenId = Array.from(crypto.getRandomValues(new Uint8Array(4)), b => b.toString(16).padStart(2, '0')).join('');
                }
            }
            console.log('Screen ID:', screenId);

            connectWebSocket();
            await generateQRCode();
            showQRCode();
            updateControllerDisplay();

            // Check for pending game from reload (when switching games)
            const pendingGame = sessionStorage.getItem('retrobox_pendingGame');
            if (pendingGame) {
                sessionStorage.removeItem('retrobox_pendingGame');
                try {
                    const gameData = JSON.parse(pendingGame);
                    // Small delay to ensure everything is initialized
                    setTimeout(() => {
                        loadROM({
                            romSource: gameData.source,
                            romName: gameData.name + '.zip', // loadROM expects extension
                            core: gameData.core,
                            biosSource: gameData.biosSource,
                            gameHeight: gameData.gameHeight,
                            threads: gameData.threads
                        });
                    }, 100);
                } catch (e) {
                    console.warn('Failed to restore pending game:', e);
                }
            }
        }

        // ============================================
        // QR CODE
        // ============================================
        let qrCodeGenerated = false;
        let cachedControllerUrl = null;

        function calculateQRSize() {
            return Math.max(Math.floor(Math.min(window.innerWidth, window.innerHeight) / 4), 120);
        }

        async function getControllerUrl() {
            if (cachedControllerUrl) return cachedControllerUrl;
            let baseUrl;
            
            // In e2e test mode, use current origin (localhost) to avoid COOP warnings
            const isE2E = new URLSearchParams(window.location.search).has('e2e');
            if (isE2E) {
                baseUrl = `${window.location.origin}/controller.html`;
            } else {
                try {
                    const res = await fetch('/api/network-info');
                    const data = await res.json();
                    if (data.url) baseUrl = `${data.url}/controller.html`;
                } catch(e) { console.warn('Network info error:', e); }
                if (!baseUrl) {
                    baseUrl = `${window.location.origin}/controller.html`;
                }
            }
            cachedControllerUrl = baseUrl + '?screen=' + screenId;
            return cachedControllerUrl;
        }

        async function generateQRCode(force = false) {
            if (qrCodeGenerated && !force) return;
            const qrDisplay = document.getElementById('qrCodeDisplay');
            const qrUrl = document.getElementById('qrUrl');
            const url = await getControllerUrl();
            const size = calculateQRSize();

            // Set URL first (before QR image generation which may fail)
            qrUrl.textContent = url;
            qrUrl.href = url;
            const containerWidth = size + 20;
            qrUrl.style.fontSize = Math.max(12, Math.min(Math.floor(containerWidth / 12), 20)) + 'px';

            qrDisplay.innerHTML = '';
            qrDisplay.style.width = qrDisplay.style.height = size + 'px';
            document.getElementById('qrContainer').style.maxWidth = (size + 40) + 'px';

            // QR image generation - may fail if library not loaded
            try {
                new window.QRCode(qrDisplay, { text: url, width: size, height: size, colorDark: '#000', colorLight: '#FFF', correctLevel: window.QRCode.CorrectLevel.H });
            } catch (e) {
                console.warn('QR code generation failed:', e.message);
            }

            qrCodeGenerated = true;
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => qrCodeGenerated && generateQRCode(true), 150);
        });

        function showQRCode() { document.getElementById('qrContainer').classList.remove('hidden'); }
        function hideQRCode() { document.getElementById('qrContainer').classList.add('hidden'); }

        // Z-index management for QR and game menu overlap on mobile
        function bringQRToFront() {
            document.getElementById('qrContainer').classList.add('front');
            document.getElementById('gameMenu')?.shadowRoot?.querySelector('.game-controls')?.classList.remove('front');
        }
        function bringMenuToFront() {
            document.getElementById('qrContainer').classList.remove('front');
            document.getElementById('gameMenu')?.shadowRoot?.querySelector('.game-controls')?.classList.add('front');
        }
        document.getElementById('qrContainer').addEventListener('click', bringQRToFront);
        document.getElementById('gameMenu')?.addEventListener('click', bringMenuToFront);

        // ============================================
        // GAME LOADING
        // ============================================
        function loadROM(gameData) {
            // Persist settings to localStorage (works for both screen and controller-initiated games)
            if (gameData.gameHeight != null) {
                localStorage.setItem('retrobox_gameHeight', gameData.gameHeight);
            }
            if (gameData.threads != null) {
                localStorage.setItem('retrobox_threads', gameData.threads);
            }

            pendingROM = {
                source: gameData.romSource,
                name: gameData.romName.split('.').slice(0, -1).join('.'),
                core: gameData.core,
                biosSource: gameData.biosSource,
                gameHeight: gameData.gameHeight || null,
                threads: gameData.threads || false
            };
            setState(State.LOADING);
            initializeEmulator();
        }

        function resetToGameMenu() {
            saveState(0);

            // Wait for save to complete before cleanup
            setTimeout(() => {
                // Clean up emulator if it exists
                try {
                    if (window.window.EJS_emulator) {
                        window.EJS_emulator.pause?.();
                        const ctx = window.EJS_emulator.Module?.AL?.currentCtx?.audioCtx;
                        if (ctx && ctx.state !== 'closed') ctx.close().catch(() => {});
                        window.window.EJS_emulator = null;
                    }
                } catch (e) { console.warn('Emulator cleanup error:', e); }

                // Remove loader script to stop any pending load
                if (loaderScript) {
                    loaderScript.remove();
                    loaderScript = null;
                }

                // Remove all EmulatorJS-injected scripts to prevent "already declared" errors
                const ejsScripts = document.querySelectorAll('script[src*="EmulatorJS/data/"]');
                ejsScripts.forEach(s => s.remove());

                // Clear global EmulatorJS identifiers to allow re-declaration
                const ejsIdentifiers = ['EJS_CommandHandler', 'HistoryManager', 'EmulatorJS', 'EJS_STORAGE',
                    'GamepadHandler', 'EJS_GameManager', 'EJSCompression'];
                ejsIdentifiers.forEach(key => { try { delete window[key]; } catch {} });

                // Clear global EmulatorJS config to prevent stale state
                const ejsGlobals = ['EJS_player', 'EJS_gameUrl', 'EJS_gameName', 'EJS_core', 'EJS_biosUrl',
                    'EJS_ready', 'EJS_onGameStart', 'EJS_onCommand', 'EJS_startOnLoaded'];
                ejsGlobals.forEach(key => { try { delete window[key]; } catch {} });

                const container = document.querySelector('.game-container');
                const gameEl = document.getElementById('game');
                gameEl.innerHTML = '';
                gameEl.style.height = gameEl.style.width = '';
                container.style.height = container.style.width = '';

                pendingROM = null;
                isPaused = false;
                setState(State.IDLE);
                broadcastToControllers({ type: 'stateUpdate', state: 'game-selection', gameName: null, isPaused: false });
            }, 1000);
        }

        async function saveState(slot) {
            if (!window.EJS_emulator?.gameManager || !window.EJS_emulator?.storage?.states) return;
            try {
                const state = window.EJS_emulator.gameManager.getState();
                const key = window.EJS_emulator.getBaseFileName() + `.state${slot}`;
                await window.EJS_emulator.storage.states.put(key, state);
                window.EJS_emulator.displayMessage?.(window.EJS_emulator.localization?.("SAVED STATE TO BROWSER") || "State saved");
            } catch (e) { console.warn('Save state failed:', e); }
        }

        async function loadState(slot) {
            if (!window.EJS_emulator?.gameManager || !window.EJS_emulator?.storage?.states) return;
            try {
                const key = window.EJS_emulator.getBaseFileName() + `.state${slot}`;
                const state = await window.EJS_emulator.storage.states.get(key);
                if (state) {
                    window.EJS_emulator.gameManager.loadState(state);
                    window.EJS_emulator.displayMessage?.(window.EJS_emulator.localization?.("LOADED STATE FROM BROWSER") || "State loaded");
                } else {
                    window.EJS_emulator.displayMessage?.("No saved state found");
                }
            } catch (e) { console.warn('Load state failed:', e); }
        }

        let fpsVisible = false; // Track FPS state (starts hidden by default)
        function toggleFPS() {
            if (!window.EJS_emulator?.gameManager) return;
            fpsVisible = !fpsVisible;
            const newValue = fpsVisible ? "show" : "hide";
            window.EJS_emulator.gameManager.setVariable("fps", newValue);
            window.EJS_emulator.displayMessage?.(`FPS: ${fpsVisible ? "ON" : "OFF"}`);
            console.log('FPS toggled:', newValue);
        }

        // Audio unlock
        let hasUserInteraction = false;
        function hideAudioIndicator() { document.getElementById('audioMutedIndicator').classList.remove('visible'); }
        function showAudioIndicator() { document.getElementById('audioMutedIndicator').classList.add('visible'); }

        ['click', 'touchstart', 'keydown', 'mousedown'].forEach(evt => {
            document.addEventListener(evt, function onInteraction() {
                hasUserInteraction = true;
                hideAudioIndicator();
                const ctx = window.EJS_emulator?.Module?.AL?.currentCtx?.audioCtx;
                if (ctx?.state === 'suspended') ctx.resume().then(() => window.EJS_emulator?.setVolume?.(1));
            }, { passive: true });
        });

        function applyGameHeight(heightPercent) {
            const container = document.querySelector('.game-container');
            const gameEl = document.getElementById('game');
            if (heightPercent) {
                container.style.height = heightPercent + 'vh';
                container.style.width = '100%';
                gameEl.style.height = gameEl.style.width = '100%';
            } else {
                container.style.height = container.style.width = '100%';
            }
        }

        function initializeEmulator() {
            window.EJS_player = '#game';
            window.EJS_pathtodata = 'EmulatorJS/data/';
            window.EJS_startOnLoaded = true;
            window.EJS_volume = 1;
            window.EJS_DEBUG_XX = true;
            window.EJS_threads = pendingROM?.threads || false;
            window.EJS_EXPERIMENTAL_NETPLAY = true;
            window.EJS_defaultControls = false;
            window.EJS_backgroundBlur = false;
            window.EJS_backgroundColor = '#1a1a1a';
            window.EJS_defaultOptions = { "save-state-location": "browser", "fps": "hide" };

            // // Enable multitap for multiplayer games
            // if (pendingROM?.core === 'psx') {
            //     window.EJS_defaultOptions["pcsx_rearmed_multitap"] = "port 1";
            // }

            // Enable optimizations for PS1 cores (pcsx_rearmed and mednafen_psx_hw)
            if (pendingROM?.core === 'psx' || pendingROM?.core === 'pcsx_rearmed') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    // "pcsx_rearmed_multitap": "port 1",
                    // Performance optimizations
                    "pcsx_rearmed_duping_enable": "enabled",
                    "pcsx_rearmed_gpu_thread_rendering": "async",
                    "pcsx_rearmed_async_cd": "async",
                    "pcsx_rearmed_drc": "enabled",
                    // Visual improvements
                    "pcsx_rearmed_dithering": "enabled",
                    "shader": "2xScaleHQ.glslp"
                };
            }
            if (pendingROM?.core === 'mednafen_psx_hw') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    // Graphics enhancements
                    "beetle_psx_hw_internal_resolution": "2x",
                    "beetle_psx_hw_pgxp_mode": "memory only",
                    "beetle_psx_hw_pgxp_texture": "enabled",
                    "beetle_psx_hw_filter": "bilinear",
                    "beetle_psx_hw_dither_mode": "disabled",
                    // Performance
                    "beetle_psx_hw_cd_fastload": "2x"
                };
            }
            // N64: disable WebGL2 to avoid glMapBufferRange errors (uses legacy WebGL1 core)
            if (pendingROM?.core === 'n64' || pendingROM?.core === 'mupen64plus_next') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    "webgl2Enabled": "disabled"
                };
            }
            if (pendingROM?.gameHeight) applyGameHeight(pendingROM.gameHeight);
            window.EJS_disableAutoLang = true;
            window.EJS_language = "en";

            if (!pendingROM) { console.error('No ROM'); setState(State.IDLE); return; }
            window.EJS_gameName = pendingROM.name;
            window.EJS_gameUrl = pendingROM.source;
            window.EJS_core = pendingROM.core;
            if (pendingROM.biosSource) window.EJS_biosUrl = pendingROM.biosSource;

            window.EJS_Buttons = {
                playPause: true, restart: true, mute: true, settings: true, fullscreen: true,
                saveState: true, loadState: true, screenRecord: true, gamepad: true, cheat: true,
                volume: true, saveSavFiles: true, loadSavFiles: true, quickSave: true, quickLoad: true,
                screenshot: true, cacheManager: true, exitEmulation: false, netplay: true,
                resetToMenu: { visible: true, displayName: "Menu", icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>', callback: resetToGameMenu }
            };

            window.EJS_ready = function() {
                // Guard: only proceed if we're still loading this game
                if (currentState !== State.LOADING || !pendingROM) {
                    console.log('EmulatorJS ready but load was cancelled');
                    return;
                }
                console.log('EmulatorJS ready');
                function autoStart() {
                    if (currentState !== State.LOADING) return; // Cancelled
                    if (window.EJS_emulator?.started) return;
                    const btn = document.querySelector('#game .ejs_start_button');
                    if (btn?.offsetParent) { btn.click(); return; }
                    setTimeout(autoStart, 200);
                }
                autoStart();
            };

            window.EJS_onGameStart = function() {
                // Guard: only proceed if we're still expecting this game to start
                if (currentState !== State.LOADING || !pendingROM) {
                    console.log('Game start callback but load was cancelled');
                    return;
                }
                console.log('Game started');
                setState(State.PLAYING);
                if (pendingROM?.gameHeight) applyGameHeight(pendingROM.gameHeight);
                setTimeout(() => {
                    if (currentState !== State.PLAYING) return; // State changed
                    const ctx = window.EJS_emulator?.Module?.AL?.currentCtx?.audioCtx;
                    if (ctx?.state === 'suspended') {
                        if (hasUserInteraction) ctx.resume().catch(() => showAudioIndicator());
                        else showAudioIndicator();
                    }
                }, 500);
                // Auto-load previous save state if "Load on start" setting is enabled
                if (localStorage.getItem('retrobox_loadOnStart') === 'true') {
                    setTimeout(() => {
                        if (currentState === State.PLAYING) loadState(0);
                    }, 2500);
                }
            };

            window.EJS_onCommand = function(evt) {
                const m = evt.method;
                if (m === 'input.simulate' && evt.params?.button === 19 && (evt.params.state === 'pressed' || evt.params.value === 1)) {
                    syncPauseUI(!isPaused);
                }
                if (m === 'control.toggle-pause' || m === 'control.togglePause' || m === 'togglePause') {
                    syncPauseUI(!isPaused);
                } else if (m === 'control.pause') {
                    syncPauseUI(true);
                } else if (m === 'control.play' || m === 'control.resume') {
                    syncPauseUI(false);
                }
            };

            // If EmulatorJS scripts were already loaded, we must reload the page
            // because const/let declarations cannot be re-declared
            if (ejsScriptsLoaded) {
                // Can only persist URL sources, not File objects
                if (typeof pendingROM.source !== 'string') {
                    alert('Cannot switch games with uploaded files. Please select from presets or use a URL.');
                    setState(State.IDLE);
                    return;
                }
                // Store game data in sessionStorage for reload
                sessionStorage.setItem('retrobox_pendingGame', JSON.stringify({
                    source: pendingROM.source,
                    name: pendingROM.name,
                    core: pendingROM.core,
                    biosSource: typeof pendingROM.biosSource === 'string' ? pendingROM.biosSource : null,
                    gameHeight: pendingROM.gameHeight,
                    threads: pendingROM.threads
                }));
                window.location.reload();
                return;
            }

            // Remove any existing loader script before adding new one
            if (loaderScript) {
                loaderScript.remove();
                loaderScript = null;
            }

            loaderScript = document.createElement('script');
            loaderScript.src = 'EmulatorJS/data/loader.js';
            loaderScript.onload = () => { ejsScriptsLoaded = true; };
            document.body.appendChild(loaderScript);
        }

        // ============================================
        // INITIALIZE
        // ============================================
        init();

        // ============================================
        // GAME MENU LOADER
        // ============================================
        (async () => {
            gameMenu = await loadGameMenuComponent(loadROM, resetToGameMenu);
            // Listen for debug mode changes from game-menu
            gameMenu?.addEventListener('debugmodechange', (e) => {
                _setDebugMode(e.detail.enabled);
                console.log('Debug mode:', e.detail.enabled ? 'enabled' : 'disabled');
            });
        })();
    </script>
</body>
</html>
