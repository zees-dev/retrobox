<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroBox</title>
    <script>
        // Disable WakeLock by intercepting errors
        const originalRequest = navigator.wakeLock?.request;
        if (originalRequest) {
            navigator.wakeLock.request = async function(...args) {
                try { return await originalRequest.apply(this, args); }
                catch (e) {
                    console.log('WakeLock error caught:', e.message);
                    return { released: false, type: args[0], release: async () => {}, addEventListener: () => {}, removeEventListener: () => {} };
                }
            };
        }

        // Console log capture for debug mode (screen logs sent to controller)
        const _screenLogs = [];
        const _maxScreenLogs = 500;
        let _debugModeEnabled = localStorage.getItem('retrobox_debugMode') === 'true';
        const _origScreenConsole = { log: console.log, warn: console.warn, error: console.error, info: console.info, debug: console.debug, trace: console.trace };

        function _formatArg(a, seen = new WeakSet()) {
            if (a === null) return 'null';
            if (a === undefined) return 'undefined';
            if (typeof a === 'function') return `[Function: ${a.name || 'anonymous'}]`;
            if (typeof a === 'symbol') return a.toString();
            if (a instanceof Error) {
                return a.stack || `${a.name}: ${a.message}`;
            }
            if (typeof a === 'object') {
                if (seen.has(a)) return '[Circular]';
                seen.add(a);
                try {
                    if (Array.isArray(a)) {
                        return '[' + a.map(x => _formatArg(x, seen)).join(', ') + ']';
                    }
                    const pairs = Object.entries(a).slice(0, 50).map(([k, v]) => `${k}: ${_formatArg(v, seen)}`);
                    return '{' + pairs.join(', ') + (Object.keys(a).length > 50 ? ', ...' : '') + '}';
                } catch { return String(a); }
            }
            return String(a);
        }

        function _captureScreenLog(type, args) {
            if (!_debugModeEnabled) return;
            const time = new Date().toTimeString().slice(0, 8);
            const msg = Array.from(args).map(a => _formatArg(a)).join(' ');
            _screenLogs.push({ time, type, msg });
            if (_screenLogs.length > _maxScreenLogs) _screenLogs.shift();
        }

        console.log = (...args) => { _captureScreenLog('log', args); _origScreenConsole.log(...args); };
        console.warn = (...args) => { _captureScreenLog('warn', args); _origScreenConsole.warn(...args); };
        console.error = (...args) => { _captureScreenLog('error', args); _origScreenConsole.error(...args); };
        console.info = (...args) => { _captureScreenLog('info', args); _origScreenConsole.info(...args); };
        console.debug = (...args) => { _captureScreenLog('debug', args); _origScreenConsole.debug(...args); };
        console.trace = (...args) => {
            _captureScreenLog('trace', [...args, '\n' + new Error().stack?.split('\n').slice(2).join('\n')]);
            _origScreenConsole.trace(...args);
        };

        // Capture uncaught errors and unhandled promise rejections
        window.addEventListener('error', (e) => {
            if (!_debugModeEnabled) return;
            const time = new Date().toTimeString().slice(0, 8);
            const msg = e.error?.stack || `${e.message} at ${e.filename}:${e.lineno}:${e.colno}`;
            _screenLogs.push({ time, type: 'error', msg: `[Uncaught] ${msg}` });
            if (_screenLogs.length > _maxScreenLogs) _screenLogs.shift();
        });
        window.addEventListener('unhandledrejection', (e) => {
            if (!_debugModeEnabled) return;
            const time = new Date().toTimeString().slice(0, 8);
            const reason = e.reason instanceof Error ? (e.reason.stack || e.reason.message) : String(e.reason);
            _screenLogs.push({ time, type: 'error', msg: `[Unhandled Promise] ${reason}` });
            if (_screenLogs.length > _maxScreenLogs) _screenLogs.shift();
        });

        function _setDebugMode(enabled) {
            _debugModeEnabled = enabled;
            if (!enabled) _screenLogs.length = 0; // Clear buffer when disabled
        }
        function _getScreenLogs() { return _screenLogs.slice(); }
    </script>
    <script src="deps/qrcode.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #1a1a1a; font-family: Arial, sans-serif; }
        body { display: flex; justify-content: center; align-items: center; }
        .game-container { width: 100%; height: 100%; border-radius: 8px; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; }
        #game { width: 100%; height: 100%; }

        #loadingOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .loading { color: #fff; text-align: center; padding: 20px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; z-index: 100; }
        .loading-spinner { margin: 20px auto; width: 50px; height: 50px; border: 3px solid rgba(255, 255, 255, 0.3); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .controllers { position: fixed; top: max(10px, 1.5vh); right: max(10px, 1.5vw); z-index: 1000; display: flex; gap: max(4px, 0.8vmin); }
        .controller-dot { width: max(6px, 1vmin); height: max(6px, 1vmin); border-radius: 50%; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15); transition: all 0.3s; position: relative; }
        .controller-dot.active { width: max(10px, 1.5vmin); height: max(10px, 1.5vmin); border: none; animation: pulse 5s ease-in-out infinite; }
        .controller-dot.active.player-0 { background: #4CAF50; box-shadow: 0 0 max(6px, 1vmin) rgba(76, 175, 80, 0.5); }
        .controller-dot.active.player-1 { background: #2196F3; box-shadow: 0 0 max(6px, 1vmin) rgba(33, 150, 243, 0.5); }
        .controller-dot.active.player-2 { background: #9C27B0; box-shadow: 0 0 max(6px, 1vmin) rgba(156, 39, 176, 0.5); }
        .controller-dot.active.player-3 { background: #FFC107; box-shadow: 0 0 max(6px, 1vmin) rgba(255, 193, 7, 0.5); }
        .controller-dot.reserved { width: max(8px, 1.2vmin); height: max(8px, 1.2vmin); opacity: 0.4; animation: none; }
        .controller-dot.reserved.player-0 { background: #4CAF50; }
        .controller-dot.reserved.player-1 { background: #2196F3; }
        .controller-dot.reserved.player-2 { background: #9C27B0; }
        .controller-dot.reserved.player-3 { background: #FFC107; }
        .controller-dot .ping { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); font-size: 8px; color: rgba(255,255,255,0.5); white-space: nowrap; margin-top: 2px; font-family: monospace; }
        .bt-controllers { position: fixed; top: calc(max(10px, 1.5vh) + max(18px, 3vmin)); right: max(10px, 1.5vw); z-index: 1000; display: flex; flex-direction: column; gap: max(3px, 0.4vmin); align-items: flex-end; }
        .bt-controller {
            display: flex; align-items: center; gap: max(3px, 0.4vmin);
            background: rgba(0,0,0,0.4); backdrop-filter: blur(6px);
            padding: max(3px, 0.35vmin) max(6px, 0.7vmin); border-radius: max(4px, 0.5vmin);
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: max(9px, 1vmin); color: rgba(255,255,255,0.75);
            border: 1px solid rgba(255,255,255,0.06);
            animation: btFadeIn 0.3s ease-out; transition: opacity 0.3s, transform 0.3s, border-color 0.3s;
        }
        .bt-controller.charging .bt-name { animation: btChargePulse 3s ease-in-out infinite; }
        .bt-controller.charging .bt-batt-wrap { animation: btChargePulse 3s ease-in-out infinite; }
        .bt-controller.charging .bt-icon { animation: btChargePulse 3s ease-in-out infinite; }
        @keyframes btChargePulse { 0%,100% { opacity: 1; color: rgba(255,255,255,0.75); } 50% { opacity: 0.85; color: #FFE082; } }
        .bt-controller.no-input { opacity: 0.45; }
        @keyframes btFadeIn { from { opacity: 0; transform: translateX(10px); } to { opacity: 1; transform: translateX(0); } }
        .bt-controller .bt-icon { width: max(14px, 1.7vmin); height: max(14px, 1.7vmin); flex-shrink: 0; line-height: 0; }
        .bt-controller .bt-icon svg { width: 100%; height: 100%; display: block; }
        .bt-controller .bt-name { min-width: max(20px, 2.5vmin); max-width: max(55px, 7vmin); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 500; letter-spacing: 0.3px; text-align: center; }
        .bt-batt-wrap { display: flex; align-items: center; line-height: 0; opacity: 0.7; }
        .bt-signal { display: flex; align-items: flex-end; gap: max(1px, 0.15vmin); height: max(10px, 1.3vmin); opacity: 0.6; }
        .bt-signal .bar { width: max(3px, 0.3vmin); border-radius: max(1px, 0.1vmin); background: rgba(255,255,255,0.3); transition: background 0.5s; }
        .bt-signal .bar.active { background: rgba(255,255,255,0.7); } /* fallback; overridden by inline brand color */
        .bt-signal .bar:nth-child(1) { height: 25%; }
        .bt-signal .bar:nth-child(2) { height: 50%; }
        .bt-signal .bar:nth-child(3) { height: 75%; }
        .bt-signal .bar:nth-child(4) { height: 100%; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.01); opacity: 0.8; } }

        .qr-container { position: fixed; top: 20px; left: 20px; z-index: 999; text-align: center; background: rgba(0, 0, 0, 0.9); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); transition: opacity 0.3s, transform 0.3s, z-index 0s; display: flex; flex-direction: column; align-items: center; cursor: pointer; }
        .qr-container.hidden { opacity: 0; transform: translateY(-20px); pointer-events: none; }
        .qr-container.front { z-index: 1002; }
        .qr-code-display { background: white; padding: 10px; border-radius: 4px; display: inline-block; margin: 5px 0; }
        .qr-code-display img, .qr-code-display canvas { display: block; width: 100% !important; height: 100% !important; }
        .qr-text { color: rgba(255, 255, 255, 0.8); font-size: max(12px, min(2.5vw, 2.5vh)); margin-bottom: 8px; font-weight: 500; }
        .qr-url { color: #4a9eff; font-family: monospace; margin-top: 8px; word-break: break-all; text-decoration: none; transition: color 0.2s; display: block; text-align: center; line-height: 1.3; }
        .qr-url:hover { color: #7bc0ff; text-decoration: underline; }

        .status { position: fixed; bottom: max(8px, 1.5vh); right: max(8px, 1.5vw); padding: max(4px, 0.8vmin) max(8px, 1.5vmin); border-radius: max(3px, 0.5vmin); font-size: max(10px, min(2vw, 2vh, 14px)); z-index: 1001; transition: opacity 0.3s, visibility 0.3s; opacity: 0.7; }
        .status.hidden { opacity: 0; visibility: hidden; }
        .status.connecting { background: #FF9800; color: #000; }
        .status.connected { background: #4CAF50; color: #fff; }
        .status.error { background: #f44336; color: #fff; }

        #audioMutedIndicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.9); color: white; padding: 12px 24px; border-radius: 8px; font-size: 16px; z-index: 3000; cursor: pointer; display: none; align-items: center; gap: 10px; border: 1px solid rgba(255, 255, 255, 0.2); }
        #audioMutedIndicator.visible { display: flex; }
        #audioMutedIndicator .icon { font-size: 24px; }
        #audioMutedIndicator .hint { font-size: 12px; opacity: 0.6; }

        #pauseOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.4); z-index: 998; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #pauseOverlay.visible { opacity: 1; }

    </style>
</head>
<body>
    <div class="qr-container" id="qrContainer">
        <div class="qr-text">Scan to connect</div>
        <div class="qr-code-display" id="qrCodeDisplay"></div>
        <a class="qr-url" id="qrUrl" href="#" target="_blank" rel="noopener"></a>
    </div>
    <div class="game-container"><div id="game"></div></div>
    <div id="loadingOverlay"><div class="loading"><div class="loading-spinner"></div></div></div>
    <div id="audioMutedIndicator">
        <span class="icon">ðŸ”‡</span>
        <div><div class="text">Audio muted</div><div class="hint">Press any key or tap to enable</div></div>
    </div>
    <div class="controllers" id="controllers"></div>
    <div class="bt-controllers" id="btControllers"></div>
    <div class="status connecting" id="status">Connecting...</div>
    <div id="pauseOverlay"></div>
    <game-menu id="gameMenu" mode="screen"></game-menu>

    <script type="module">
        import {
            P2P_PING, P2P_DIGITAL, P2P_ANALOG, P2P_TOGGLE_FPS, P2P_SAVE_STATE,
            P2P_LOAD_STATE, P2P_RESET_MENU, P2P_HARD_REFRESH, P2P_STATE_UPDATE,
            P2P_RTT_ECHO, P2P_STATES, HEARTBEAT_INTERVAL, WebSocketManager,
            IceCandidateBuffer, loadGameMenuComponent, RESOLUTION_OPTIONS
        } from './common.js';

        // ============================================
        // CONSTANTS
        // ============================================
        const GRACE_PERIOD = 7500;

        // ============================================
        // STATE
        // ============================================
        const State = { IDLE: 'game-selection', LOADING: 'game-pending', PLAYING: 'game-ready' };
        let currentState = State.IDLE;
        let pendingROM = null;
        let isPaused = false;
        let gameMenu = null;

        let wsManager = null;
        let screenId = null;
        let loaderScript = null; // Track the loader script element
        let wakeLock = null; // Wake lock to prevent screen off when controller connected
        let ejsScriptsLoaded = false; // Track if EmulatorJS scripts have been loaded (can't be unloaded)

        // Wake lock management
        async function acquireWakeLock() {
            if (wakeLock) return; // Already held
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake lock acquired - screen will stay on');
                wakeLock.addEventListener('release', () => {
                    console.log('Wake lock released');
                    wakeLock = null;
                });
            } catch (e) {
                console.log('Wake lock request failed:', e.message);
            }
        }

        async function releaseWakeLock() {
            if (!wakeLock) return;
            try {
                await wakeLock.release();
                wakeLock = null;
                console.log('Wake lock manually released');
            } catch (e) {
                console.log('Wake lock release failed:', e.message);
            }
        }

        // ============================================
        // WEBRTC P2P STATE
        // ============================================
        const peers = new Map(); // controllerId -> { pc, channel, playerNum, rtt, iceBuffer }
        const pendingRemoval = new Map(); // controllerId -> timeout
        const lastInputTs = new Map(); // controllerId -> Uint32Array(32) per-button timestamps
        // Pre-allocated echo buffer: [messageType:1][timestamp:4] = 5 bytes
        const echoBuf = new ArrayBuffer(5);
        const echoView = new DataView(echoBuf);

        // P2P stateUpdate sender
        const stateUpdateBuf = new ArrayBuffer(256);
        const stateUpdateBytes = new Uint8Array(stateUpdateBuf);
        const textEncoder = new TextEncoder();

        function sendP2PStateUpdate(peer, stateEnum, isPaused, core, gameName) {
            if (peer?.channel?.readyState !== 'open') return false;
            let o = 0;
            stateUpdateBytes[o++] = P2P_STATE_UPDATE;
            stateUpdateBytes[o++] = stateEnum;
            stateUpdateBytes[o++] = isPaused ? 1 : 0;
            const coreBytes = core ? textEncoder.encode(core) : null;
            stateUpdateBytes[o++] = coreBytes?.length || 0;
            if (coreBytes) { stateUpdateBytes.set(coreBytes, o); o += coreBytes.length; }
            const nameBytes = gameName ? textEncoder.encode(gameName) : null;
            stateUpdateBytes[o++] = nameBytes?.length || 0;
            if (nameBytes) { stateUpdateBytes.set(nameBytes, o); o += nameBytes.length; }
            peer.channel.send(new Uint8Array(stateUpdateBuf, 0, o));
            return true;
        }

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        function getStateInfo() {
            return { type: 'stateUpdate', state: currentState, gameName: pendingROM?.name, core: pendingROM?.core, isPaused };
        }

        function setState(newState) {
            if (currentState === newState) return;
            console.log(`State: ${currentState} -> ${newState}`);
            currentState = newState;
            updateScreenUI();
            broadcastToControllers(getStateInfo());
        }

        function broadcastToControllers(msg) {
            // Send stateUpdate via P2P for low latency
            if (msg.type === 'stateUpdate') {
                const stateEnum = P2P_STATES.indexOf(msg.state);
                for (const [, peer] of peers) {
                    sendP2PStateUpdate(peer, stateEnum >= 0 ? stateEnum : 0, msg.isPaused, msg.core, msg.gameName);
                }
            }
            // Always also send via WS (fallback for controllers without P2P)
            wsManager?.send(msg);
        }

        function updateScreenUI() {
            switch (currentState) {
                case State.IDLE:
                    gameMenu?.show(); hidePauseOverlay(); showQRCode(); showStatus(); break;
                case State.LOADING:
                    gameMenu?.setLoadingText(`Loading ${pendingROM?.name || 'game'}...`);
                    gameMenu?.showLoading(); hidePauseOverlay(); hideQRCode(); hideStatus(); break;
                case State.PLAYING:
                    gameMenu?.hide(); hideStatus();
                    if (isPaused) { showPauseOverlay(); showQRCode(); } else { hidePauseOverlay(); hideQRCode(); }
                    break;
            }
        }

        function showStatus() { document.getElementById('status').classList.remove('hidden'); }
        function hideStatus() { document.getElementById('status').classList.add('hidden'); }

        // ============================================
        // PAUSE
        // ============================================
        function syncPauseUI(paused) {
            if (currentState !== State.PLAYING) return;
            isPaused = paused;
            if (isPaused) { showPauseOverlay(); showQRCode(); } else { hidePauseOverlay(); hideQRCode(); }
            broadcastToControllers(getStateInfo());
        }

        function setPause(paused) {
            if (currentState !== State.PLAYING || isPaused === paused) return;
            if (paused) window.EJS_emulator?.pause?.(); else window.EJS_emulator?.play?.();
            syncPauseUI(paused);
        }

        function showPauseOverlay() { document.getElementById('pauseOverlay').classList.add('visible'); }
        function hidePauseOverlay() { document.getElementById('pauseOverlay').classList.remove('visible'); }

        // ============================================
        // WEBSOCKET
        // ============================================
        function updateStatus(status, text) {
            const el = document.getElementById('status');
            el.className = 'status ' + status;
            el.textContent = text;
        }

        function connectWebSocket() {
            updateStatus('connecting', 'Connecting...');
            wsManager = new WebSocketManager({
                onOpen: () => {
                    console.log('WebSocket connected, registering as screen:', screenId);
                    wsManager.send({ type: 'register-screen', screenId });
                },
                onMessage: handleMessage,
                onClose: () => {
                    console.log('WebSocket disconnected, reconnecting...');
                    updateStatus('connecting', 'Reconnecting...');
                },
                onError: err => {
                    console.error('WebSocket error:', err);
                    updateStatus('error', 'Connection error');
                }
            });
            wsManager.connect();
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'registered':
                    console.log('Screen registered:', msg.screenId);
                    updateStatus('connected', 'Ready: ' + screenId);
                    break;

                case 'controller-connected':
                    handleControllerConnected(msg.controllerId, msg.playerNum);
                    break;

                case 'controller-disconnected':
                    handleControllerDisconnected(msg.controllerId, msg.playerNum);
                    break;

                case 'webrtc-offer':
                    handleWebRTCOffer(msg.from, msg.offer);
                    break;

                case 'ice-candidate':
                    handleRemoteIceCandidate(msg.from, msg.candidate);
                    break;

                case 'heartbeat-ack':
                    break;

                case 'btControllersUpdate':
                    renderBtControllers(msg.controllers || []);
                    break;

                case 'startGame':
                    if (msg.gameData) loadROM(msg.gameData);
                    break;

                case 'resetToMenu':
                    resetToGameMenu();
                    break;

                case 'hardRefresh':
                    console.log('Hard refresh requested by controller');
                    window.location.reload();
                    break;

                case 'toggleFPS':
                    toggleFPS();
                    break;

                case 'saveState':
                    saveState(msg.slot);
                    break;

                case 'loadState':
                    loadState(msg.slot);
                    break;

                case 'setSetting':
                    // Apply setting from controller
                    if (window.EJS_emulator?.handler && msg.setting) {
                        try {
                            window.EJS_emulator.handler.exec('settings.change', { setting: msg.setting, value: msg.value });
                            console.log('Setting applied from controller:', msg.setting, '=', msg.value);
                        } catch (e) { console.error('Setting error:', e); }
                    }
                    break;

                case 'toggleCheat':
                    if (window.EJS_emulator && msg.index !== undefined) {
                        try {
                            window.EJS_emulator.cheats[msg.index].checked = msg.checked;
                            window.EJS_emulator.cheatChanged(msg.checked, msg.code, msg.index);
                            console.log(`[cheats] ${msg.checked ? 'ON' : 'OFF'}: index=${msg.index}`);
                        } catch (e) { console.error('[cheats] Toggle error:', e); }
                    }
                    break;

                case 'getSettings':
                    // Send current settings to requesting controller (server adds controllerId to msg)
                    if (window.EJS_emulator?.settings && msg.controllerId) {
                        wsManager?.send({
                            type: 'settingsSync',
                            targetController: msg.controllerId,
                            settings: window.EJS_emulator.settings,
                            core: pendingROM?.core
                        });
                        console.log('Sent settings sync to controller:', msg.controllerId);
                    }
                    break;

                case 'menuSetting':
                    // Apply menu setting from controller (gameHeight, threads, debugMode) and persist
                    if (msg.setting && gameMenu) {
                        gameMenu.applySetting(msg.setting, msg.value);
                        console.log('Menu setting applied from controller:', msg.setting, '=', msg.value);
                        // Update debug mode state for log buffering
                        if (msg.setting === 'debugMode') {
                            _setDebugMode(msg.value === true || msg.value === 'true');
                        }
                    }
                    break;

                case 'getScreenLogs':
                    // Send screen logs to requesting controller
                    if (msg.controllerId) {
                        wsManager?.send({
                            type: 'screenLogs',
                            targetController: msg.controllerId,
                            logs: _getScreenLogs(),
                            debugMode: _debugModeEnabled
                        });
                        console.log('Sent screen logs to controller:', msg.controllerId, '(' + _getScreenLogs().length + ' logs)');
                    }
                    break;

                default:
                    // Handle input and other commands from controller (WebSocket fallback)
                    if (currentState === State.PLAYING && window.EJS_emulator?.handler && msg.method) {
                        try {
                            window.EJS_emulator.handler.exec(msg.method, msg.params);
                            // Log non-input commands for debugging
                            if (msg.method !== 'input.simulate') {
                                console.log('Command from controller:', msg.method, msg.params);
                            }
                        }
                        catch (e) { console.error('Command error:', e); }
                    }
            }
        }

        // ============================================
        // WEBRTC P2P (Screen side)
        // ============================================
        function handleControllerConnected(controllerId, playerNum) {
            console.log('Controller connected:', controllerId, 'Player', playerNum + 1);

            // Cancel pending removal if reconnecting
            if (pendingRemoval.has(controllerId)) {
                clearTimeout(pendingRemoval.get(controllerId));
                pendingRemoval.delete(controllerId);
                console.log('[WebRTC] Reconnection within grace period, restored Player', playerNum + 1);
            }

            // Track peer (P2P connection created on offer)
            if (!peers.has(controllerId)) {
                peers.set(controllerId, { pc: null, channel: null, playerNum, rtt: 0, iceBuffer: new IceCandidateBuffer() });
            }

            // Acquire wake lock when controller connects
            acquireWakeLock();

            updateControllerDisplay();
            wsManager?.send({ ...getStateInfo(), targetController: controllerId });

            // Send current menu settings to the newly connected controller
            const gameHeight = parseInt(localStorage.getItem('retrobox_gameHeight') || '100');
            const threads = localStorage.getItem('retrobox_threads') === 'true';
            const debugMode = localStorage.getItem('retrobox_debugMode') === 'true';
            const loadOnStart = localStorage.getItem('retrobox_loadOnStart') === 'true';
            let resolution = {};
            try { resolution = JSON.parse(localStorage.getItem('retrobox_resolution') || '{}'); } catch {}
            let webgl2 = {};
            try { webgl2 = JSON.parse(localStorage.getItem('retrobox_webgl2') || '{}'); } catch {}
            wsManager?.send({
                type: 'menuSettingsSync',
                targetController: controllerId,
                settings: { gameHeight, threads, debugMode, loadOnStart, resolution, webgl2 }
            });
        }

        function handleControllerDisconnected(controllerId, playerNum) {
            console.log('Controller disconnected:', controllerId, 'Player', playerNum + 1);

            // Start grace period for reconnection
            const timeout = setTimeout(() => {
                console.log('[WebRTC] Grace period expired for Player', playerNum + 1);
                const peer = peers.get(controllerId);
                if (peer?.pc) try { peer.pc.close(); } catch {}
                peers.delete(controllerId);
                pendingRemoval.delete(controllerId);
                updateControllerDisplay();


                // Release wake lock when no controllers connected
                if (peers.size === 0) {
                    releaseWakeLock();
                }
                // Auto-pause when no controllers
                if (peers.size === 0 && currentState === State.PLAYING && !isPaused) {
                    console.log('No controllers, pausing...');
                    setPause(true);
                }
            }, GRACE_PERIOD);

            pendingRemoval.set(controllerId, timeout);
            updateControllerDisplay();
        }

        function getNextPlayerNum() {
            const used = new Set([...peers.values()].map(p => p.playerNum));
            for (let i = 0; i < 4; i++) if (!used.has(i)) return i;
            return peers.size;
        }

        function handleWebRTCOffer(controllerId, offer) {
            console.log('[WebRTC] Received offer from:', controllerId);

            let peer = peers.get(controllerId);
            if (!peer) {
                peer = { pc: null, channel: null, playerNum: getNextPlayerNum(), rtt: 0, iceBuffer: new IceCandidateBuffer() };
                peers.set(controllerId, peer);
            }

            // Close existing connection if any
            if (peer.pc) try { peer.pc.close(); } catch {}
            peer.iceBuffer.reset();

            const pc = new RTCPeerConnection({ iceServers: [] });
            peer.pc = pc;

            pc.ondatachannel = e => {
                console.log('[WebRTC] DataChannel received from:', controllerId);
                const ch = e.channel;
                peer.channel = ch;
                ch.binaryType = 'arraybuffer';

                ch.onmessage = evt => handleP2PMessage(controllerId, evt.data);
                ch.onclose = () => console.log('[WebRTC] DataChannel closed:', controllerId);
                ch.onerror = err => console.error('[WebRTC] DataChannel error:', controllerId, err);
            };

            pc.onicecandidate = e => {
                if (e.candidate) wsManager?.send({ type: 'ice-candidate', to: controllerId, candidate: e.candidate });
            };

            pc.onconnectionstatechange = () => {
                console.log('[WebRTC] Connection state:', controllerId, pc.connectionState);
            };

            pc.setRemoteDescription(offer).then(() => {
                peer.iceBuffer.flush(pc);
                return pc.createAnswer();
            }).then(answer => {
                pc.setLocalDescription(answer);
                wsManager?.send({ type: 'webrtc-answer', to: controllerId, answer });
                console.log('[WebRTC] Sent answer to:', controllerId);
            });
        }

        function handleRemoteIceCandidate(controllerId, candidate) {
            const peer = peers.get(controllerId);
            if (!peer?.pc) return;
            peer.iceBuffer.add(candidate, peer.pc);
        }

        function handleP2PMessage(controllerId, data) {
            const view = new DataView(data);
            const methodId = view.getUint8(0);
            const peer = peers.get(controllerId);

            switch (methodId) {
                case P2P_PING:
                    if (peer) {
                        const newRtt = view.getUint16(5, true);
                        if (peer.rtt !== newRtt) {
                            peer.rtt = newRtt;
                            updateControllerDisplay();
                        }
                    }
                    // Send RTT echo for ping measurement
                    const pingTs = view.getUint32(1, false);
                    if (peer?.channel?.readyState === 'open') {
                        echoView.setUint8(0, P2P_RTT_ECHO);
                        echoView.setUint32(1, pingTs, false);
                        peer.channel.send(echoBuf);
                    }
                    return;
                case P2P_TOGGLE_FPS: toggleFPS(); return;
                case P2P_SAVE_STATE: saveState(view.byteLength > 1 ? view.getUint8(1) : 1); return;
                case P2P_LOAD_STATE: loadState(view.byteLength > 1 ? view.getUint8(1) : 1); return;
                case P2P_RESET_MENU: resetToGameMenu(); return;
                case P2P_HARD_REFRESH: window.location.reload(); return;
                case P2P_DIGITAL:
                case P2P_ANALOG:
                    break; // Fall through to input handling
                default:
                    return; // Unknown method
            }

            // Input messages (1=digital, 2=analog) - no RTT echo on input (ping handles RTT separately)

            if (currentState !== State.PLAYING || !window.EJS_emulator?.handler) return;

            const button = view.getUint8(5);
            const ts = view.getUint32(1, false);
            const player = peer?.playerNum ?? 0;
            const isAnalog = methodId === P2P_ANALOG;
            const value = isAnalog ? view.getUint16(6, true) : view.getUint8(6);
            const state = isAnalog ? 'analog' : (value === 1 ? 'pressed' : 'released');

            // Reject stale out-of-order messages per button (unordered channel)
            if (!isAnalog) {
                let btnTs = lastInputTs.get(controllerId);
                if (!btnTs) { btnTs = new Uint32Array(32); lastInputTs.set(controllerId, btnTs); }
                if (ts < btnTs[button]) return;
                btnTs[button] = ts;
            }

            try {
                window.EJS_emulator.handler.exec('input.simulate', { button, player, state, value });
            } catch (e) {
                console.error('P2P input error:', e);
            }
        }

        function updateControllerDisplay() {
            const container = document.getElementById('controllers');
            container.innerHTML = '';

            // Build player map from peers
            const playerMap = new Map();
            for (const [id, peer] of peers) {
                const isReserved = pendingRemoval.has(id);
                playerMap.set(peer.playerNum, { connected: !isReserved, reserved: isReserved, rtt: peer.rtt });
            }

            for (let i = 0; i < 4; i++) {
                const info = playerMap.get(i);

                // Top-right corner dots with ping
                const dot = document.createElement('div');
                dot.className = 'controller-dot';
                if (info) {
                    dot.classList.add(info.connected ? 'active' : 'reserved', `player-${i}`);
                    if (info.connected && info.rtt > 0) {
                        const ping = document.createElement('span');
                        ping.className = 'ping';
                        ping.textContent = info.rtt + 'ms';
                        dot.appendChild(ping);
                    }
                }
                container.appendChild(dot);
            }

            // Update game menu player status
            gameMenu?.updatePlayerStatus(playerMap);
        }

        // ============================================
        // BLUETOOTH CONTROLLERS (WebSocket-driven, real-time)
        // ============================================
        // Brand-specific SVG icons (MDI / simple-icons, viewBox 0 0 24 24)
        const BT_ICONS = {
            playstation: { color: '#4A90D9', svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M9.5 4.27c1.38.26 3.4.87 4.5 1.23c2.75.95 3.69 2.13 3.69 4.79c0 2.6-1.6 3.58-3.64 2.6V8.05c0-.55-.1-1.08-.64-1.23c-.41-.13-.65.25-.65.81v12.1L9.5 18.69zm3.87 13.35l5.25-1.87c.6-.21.69-.51.21-.67c-.49-.16-1.36-.11-1.96.1l-3.5 1.23v-1.96l.21-.07s1.01-.38 2.42-.51c1.43-.16 3.17.02 4.53.53c1.54.49 1.72 1.21 1.33 1.7c-.4.5-1.36.85-1.36.85l-7.13 2.55zm-9.87-.2C1.93 17 1.66 16.05 2.38 15.5c.67-.5 1.8-.85 1.8-.85L8.86 13v1.88L5.5 16.09c-.6.21-.69.51-.21.67s1.36.12 1.95-.1l1.62-.58v1.69l-.32.06c-1.62.26-3.34.17-5.04-.41"/></svg>' },
            xbox: { color: '#5DC21E', svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M6.43 3.72c.07-.06.14-.12.19-.16C8.18 2.55 10 2 12 2c1.88 0 3.64.5 5.14 1.42c.11.08.4.27.56.46C16.25 2.28 12 5.7 12 5.7c-1.5-1.13-2.83-1.9-3.84-2.2c-.85-.21-1.43 0-1.7.2m12.88 1.51c-.05-.05-.1-.1-.14-.15c-.36-.4-.82-.5-1.2-.47c-.39.12-2.1.73-4.2 2.72c0 0 2.37 2.3 3.82 4.65s2.31 4.2 1.78 6.77C21 16.95 22 14.59 22 12c0-2.62-1-5-2.66-6.79m-3.61 7.75c-.65-.72-1.6-1.75-2.87-3.01c-.27-.27-.56-.55-.86-.85c0 0-.47.46-1.07 1.07c-.77.77-1.76 1.78-2.32 2.37c-.98 1.05-3.8 4.35-3.96 6.2c0 0-.65-1.46.75-4.85c.9-2.21 3.6-5.53 4.75-6.61c0 0-1.03-1.14-2.33-1.93l-.05-.03c-.63-.37-1.31-.66-1.97-.7c-.67.05-1.09.54-1.09.54A9.95 9.95 0 0 0 2 12a10 10 0 0 0 10 10c2.93 0 5.57-1.26 7.4-3.27c0 0-.21-1.33-1.56-3.23c-.31-.43-1.47-1.81-2.11-2.54"/></svg>' },
            switch: { color: '#E60012', svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M10.04 20.4H7.12c-.93 0-1.82-.4-2.48-1.04C4 18.7 3.6 17.81 3.6 16.88V7.12c0-.93.4-1.82 1.04-2.48C5.3 4 6.19 3.62 7.12 3.62h2.92zM7.12 2A5.12 5.12 0 0 0 2 7.12v9.76C2 19.71 4.29 22 7.12 22h4.53V2zM5.11 8c0 1.04.84 1.88 1.89 1.88c1.03 0 1.87-.84 1.87-1.88S8.03 6.12 7 6.12c-1.05 0-1.89.84-1.89 1.88m12.5 3c1.11 0 2.01.89 2.01 2c0 1.12-.9 2-2.01 2s-2.03-.88-2.03-2c0-1.11.92-2 2.03-2m-.73 11A5.12 5.12 0 0 0 22 16.88V7.12C22 4.29 19.71 2 16.88 2h-3.23v20z"/></svg>' },
            gamesir: { color: '#E67E22', svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M7 6h10a6 6 0 0 1 6 6a6 6 0 0 1-6 6c-1.78 0-3.37-.77-4.47-2h-1.06c-1.1 1.23-2.69 2-4.47 2a6 6 0 0 1-6-6a6 6 0 0 1 6-6M6 9v2H4v2h2v2h2v-2h2v-2H8V9zm9.5 3a1.5 1.5 0 0 0-1.5 1.5a1.5 1.5 0 0 0 1.5 1.5a1.5 1.5 0 0 0 1.5-1.5a1.5 1.5 0 0 0-1.5-1.5m3-3a1.5 1.5 0 0 0-1.5 1.5a1.5 1.5 0 0 0 1.5 1.5a1.5 1.5 0 0 0 1.5-1.5A1.5 1.5 0 0 0 18.5 9"/></svg>' },
            '8bitdo': { color: '#D4A017', svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M7.97 16L5 19c-.33.3-.77.5-1.25.5A1.75 1.75 0 0 1 2 17.75v-.25l1-7.38A4.524 4.524 0 0 1 7.5 6h9c2.36 0 4.29 1.81 4.5 4.12l1 7.38v.25a1.75 1.75 0 0 1-1.75 1.75c-.48 0-.92-.2-1.25-.5l-2.97-3zM7 8v2H5v1h2v2h1v-2h2v-1H8V8zm9.5 0a.75.75 0 0 0-.75.75a.75.75 0 0 0 .75.75a.75.75 0 0 0 .75-.75a.75.75 0 0 0-.75-.75m-1.75 1.75a.75.75 0 0 0-.75.75a.75.75 0 0 0 .75.75a.75.75 0 0 0 .75-.75a.75.75 0 0 0-.75-.75m3.5 0a.75.75 0 0 0-.75.75a.75.75 0 0 0 .75.75a.75.75 0 0 0 .75-.75a.75.75 0 0 0-.75-.75M16.5 11.5a.75.75 0 0 0-.75.75a.75.75 0 0 0 .75.75a.75.75 0 0 0 .75-.75a.75.75 0 0 0-.75-.75"/></svg>' },
            generic: { color: '#999', svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M7.97 16L5 19c-.33.3-.77.5-1.25.5A1.75 1.75 0 0 1 2 17.75v-.25l1-7.38A4.524 4.524 0 0 1 7.5 6h9c2.36 0 4.29 1.81 4.5 4.12l1 7.38v.25a1.75 1.75 0 0 1-1.75 1.75c-.48 0-.92-.2-1.25-.5l-2.97-3zM7 8v2H5v1h2v2h1v-2h2v-1H8V8zm9.5 0a.75.75 0 0 0-.75.75a.75.75 0 0 0 .75.75a.75.75 0 0 0 .75-.75a.75.75 0 0 0-.75-.75m-1.75 1.75a.75.75 0 0 0-.75.75a.75.75 0 0 0 .75.75a.75.75 0 0 0 .75-.75a.75.75 0 0 0-.75-.75m3.5 0a.75.75 0 0 0-.75.75a.75.75 0 0 0 .75.75a.75.75 0 0 0 .75-.75a.75.75 0 0 0-.75-.75M16.5 11.5a.75.75 0 0 0-.75.75a.75.75 0 0 0 .75.75a.75.75 0 0 0 .75-.75a.75.75 0 0 0-.75-.75"/></svg>' }
        };

        function batteryIcon(pct, status) {
            if (pct === null || pct === undefined) return '';
            const bars = pct >= 60 ? 3 : pct >= 25 ? 2 : pct >= 10 ? 1 : 0;
            const charging = status === 'Charging' || status === 'Full';
            const outline = charging ? '#FFD54F' : (pct < 10 ? '#f44336' : 'rgba(255,255,255,0.7)');
            const fill = pct < 10 ? '#f44336' : 'rgba(255,255,255,0.7)';
            const w = window.innerWidth > 1200 ? 18 : 14;
            const h = window.innerWidth > 1200 ? 9 : 7;
            return '<svg class="bt-batt" viewBox="0 0 20 10" width="' + w + '" height="' + h + '">'
                + '<rect x="0.5" y="0.5" width="16" height="9" rx="1.5" fill="none" stroke="' + outline + '" stroke-width="1"/>'
                + '<rect x="16.5" y="3" width="2" height="4" rx="0.5" fill="' + outline + '"/>'
                + (bars >= 1 ? '<rect x="2" y="2" width="4" height="6" rx="0.5" fill="' + fill + '"/>' : '')
                + (bars >= 2 ? '<rect x="7" y="2" width="4" height="6" rx="0.5" fill="' + fill + '"/>' : '')
                + (bars >= 3 ? '<rect x="12" y="2" width="3" height="6" rx="0.5" fill="' + fill + '"/>' : '')
                + (charging ? '<path d="M9.5 1l-3 4h2.2L7 9l4.5-4.5h-2z" fill="#FFD54F"><animate attributeName="opacity" values="1;0.5;1" dur="0.8s" repeatCount="indefinite"/></path>' : '')
                + '</svg>';
        }

        function rssiToBars(rssi) {
            if (rssi === null || rssi === undefined) return 0;
            if (rssi >= -25) return 4;  // excellent â€” right next to it
            if (rssi >= -50) return 3;  // strong â€” same room
            if (rssi >= -60) return 2;  // good â€” gaming distance
            if (rssi >= -75) return 1;  // weak â€” far / through walls
            return 0;
        }

        function renderBtControllers(btControllersList) {
            const container = document.getElementById('btControllers');
            const list = btControllersList || [];
            const incomingAddrs = new Set(list.map(c => c.address));
            const existingEls = new Map();
            for (const el of [...container.children]) existingEls.set(el.dataset.addr, el);

            // Remove gone controllers (fade out then remove)
            for (const [addr, el] of existingEls) {
                if (!incomingAddrs.has(addr)) {
                    el.style.opacity = '0'; el.style.transform = 'translateX(10px)';
                    setTimeout(() => el.remove(), 300);
                }
            }

            // Add or update each controller
            for (const c of list) {
                const info = BT_ICONS[c.type] || BT_ICONS.generic;
                const bars = rssiToBars(c.rssi);
                const title = c.rssi !== null ? c.name + ' (' + c.rssi + ' dBm)' : c.name;
                const existing = existingEls.get(c.address);

                if (existing) {
                    // Update in-place â€” no animation re-trigger
                    existing.title = title;
                    existing.classList.toggle('no-input', !c.inputActive);
                    const isChg = c.batteryStatus === 'Charging' || c.batteryStatus === 'Full';
                    existing.classList.toggle('charging', isChg);
                    const nameEl = existing.querySelector('.bt-name');
                    if (nameEl) nameEl.textContent = isChg ? 'âš¡' : (c.displayName || c.name);
                    const barEls = existing.querySelectorAll('.bt-signal .bar');
                    barEls.forEach((bar, i) => {
                        const active = (i + 1) <= bars;
                        bar.classList.toggle('active', active);
                        bar.style.background = active ? info.color : '';
                    });
                    // Update battery
                    const battEl = existing.querySelector('.bt-batt-wrap');
                    const battHtml = batteryIcon(c.battery, c.batteryStatus);
                    if (battEl) { battEl.innerHTML = battHtml; }
                    else if (battHtml) {
                        const wrap = document.createElement('span');
                        wrap.className = 'bt-batt-wrap';
                        wrap.innerHTML = battHtml;
                        existing.querySelector('.bt-signal')?.before(wrap);
                    }
                } else {
                    // New controller â€” create with entrance animation
                    const div = document.createElement('div');
                    const isCharging = c.batteryStatus === 'Charging' || c.batteryStatus === 'Full';
                    div.className = 'bt-controller' + (c.inputActive ? '' : ' no-input') + (isCharging ? ' charging' : '');
                    div.dataset.addr = c.address;
                    div.title = title;
                    const isBt = !c.connectionType || c.connectionType === 'bluetooth';
                    let connHtml = '';
                    if (isBt) {
                        connHtml = '<div class="bt-signal">' + [1,2,3,4].map(i => {
                            const active = i <= bars;
                            return '<div class="bar' + (active ? ' active' : '') + '"'
                                + (active ? ' style="background:' + info.color + '"' : '') + '></div>';
                        }).join('') + '</div>';
                    } else {
                        // USB/dongle: show plug icon instead of signal bars
                        const connIcon = c.connectionType === 'dongle' ? 'ðŸ“¡' : 'ðŸ”Œ';
                        connHtml = '<span style="font-size:max(8px,1vmin);opacity:0.5">' + connIcon + '</span>';
                    }
                    const battHtml = batteryIcon(c.battery, c.batteryStatus);
                    const nameText = isCharging ? 'âš¡' : (c.displayName || c.name);
                    div.innerHTML = '<span class="bt-icon" style="color:' + info.color + '">' + info.svg + '</span>'
                        + '<span class="bt-name">' + nameText + '</span>'
                        + (battHtml ? '<span class="bt-batt-wrap">' + battHtml + '</span>' : '')
                        + connHtml;
                    container.appendChild(div);
                }
            }
        }

        // Initialize
        async function init() {
            const urlParams = new URLSearchParams(window.location.search);
            const isE2E = urlParams.has('e2e');
            
            if (urlParams.get('host')) {
                screenId = urlParams.get('host').replace(/\./g, '-');
            } else if (isE2E) {
                // E2E tests use a unique random screenId to avoid conflicts with production kiosk
                screenId = 'e2e-' + Array.from(crypto.getRandomValues(new Uint8Array(4)), b => b.toString(16).padStart(2, '0')).join('');
            } else {
                try {
                    const res = await fetch('/api/client-hostname');
                    const data = await res.json();
                    screenId = (data.hostname || data.ip || 'unknown').replace(/\./g, '-');
                } catch (e) {
                    console.warn('Could not fetch hostname, using random ID');
                    screenId = Array.from(crypto.getRandomValues(new Uint8Array(4)), b => b.toString(16).padStart(2, '0')).join('');
                }
            }
            console.log('Screen ID:', screenId);

            connectWebSocket();
            await generateQRCode();
            showQRCode();
            updateControllerDisplay();

            // Check for pending game from reload (when switching games)
            const pendingGame = sessionStorage.getItem('retrobox_pendingGame');
            if (pendingGame) {
                sessionStorage.removeItem('retrobox_pendingGame');
                try {
                    const gameData = JSON.parse(pendingGame);
                    // Small delay to ensure everything is initialized
                    setTimeout(() => {
                        loadROM({
                            romSource: gameData.source,
                            romName: gameData.name + '.zip', // loadROM expects extension
                            core: gameData.core,
                            biosSource: gameData.biosSource,
                            gameHeight: gameData.gameHeight,
                            threads: gameData.threads,
                            resolution: gameData.resolution,
                            webgl2: gameData.webgl2
                        });
                    }, 100);
                } catch (e) {
                    console.warn('Failed to restore pending game:', e);
                }
            }
        }

        // ============================================
        // QR CODE
        // ============================================
        let qrCodeGenerated = false;
        let cachedControllerUrl = null;

        function calculateQRSize() {
            return Math.max(Math.floor(Math.min(window.innerWidth, window.innerHeight) / 4), 120);
        }

        async function getControllerUrl() {
            if (cachedControllerUrl) return cachedControllerUrl;
            let baseUrl;
            
            // In e2e test mode, use current origin (localhost) to avoid COOP warnings
            const isE2E = new URLSearchParams(window.location.search).has('e2e');
            if (isE2E) {
                baseUrl = `${window.location.origin}/controller.html`;
            } else {
                try {
                    const res = await fetch('/api/network-info');
                    const data = await res.json();
                    if (data.url) baseUrl = `${data.url}/controller.html`;
                } catch(e) { console.warn('Network info error:', e); }
                if (!baseUrl) {
                    baseUrl = `${window.location.origin}/controller.html`;
                }
            }
            cachedControllerUrl = baseUrl + '?screen=' + screenId;
            return cachedControllerUrl;
        }

        async function generateQRCode(force = false) {
            if (qrCodeGenerated && !force) return;
            const qrDisplay = document.getElementById('qrCodeDisplay');
            const qrUrl = document.getElementById('qrUrl');
            const url = await getControllerUrl();
            const size = calculateQRSize();

            // Set URL first (before QR image generation which may fail)
            qrUrl.textContent = url;
            qrUrl.href = url;
            const containerWidth = size + 20;
            qrUrl.style.fontSize = Math.max(12, Math.min(Math.floor(containerWidth / 12), 20)) + 'px';

            qrDisplay.innerHTML = '';
            qrDisplay.style.width = qrDisplay.style.height = size + 'px';
            document.getElementById('qrContainer').style.maxWidth = (size + 40) + 'px';

            // QR image generation - may fail if library not loaded
            try {
                new window.QRCode(qrDisplay, { text: url, width: size, height: size, colorDark: '#000', colorLight: '#FFF', correctLevel: window.QRCode.CorrectLevel.H });
            } catch (e) {
                console.warn('QR code generation failed:', e.message);
            }

            qrCodeGenerated = true;
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => qrCodeGenerated && generateQRCode(true), 150);
        });

        function showQRCode() { document.getElementById('qrContainer').classList.remove('hidden'); }
        function hideQRCode() { document.getElementById('qrContainer').classList.add('hidden'); }

        // Z-index management for QR and game menu overlap on mobile
        function bringQRToFront() {
            document.getElementById('qrContainer').classList.add('front');
            document.getElementById('gameMenu')?.shadowRoot?.querySelector('.game-controls')?.classList.remove('front');
        }
        function bringMenuToFront() {
            document.getElementById('qrContainer').classList.remove('front');
            document.getElementById('gameMenu')?.shadowRoot?.querySelector('.game-controls')?.classList.add('front');
        }
        document.getElementById('qrContainer').addEventListener('click', bringQRToFront);
        document.getElementById('gameMenu')?.addEventListener('click', bringMenuToFront);

        // ============================================
        // GAME LOADING
        // ============================================
        async function loadROM(gameData) {
            // Native mode: call API directly (kiosk will die after this)
            if (gameData.playMode === 'native') {
                gameMenu?.setLoadingText('Launching native mode...');
                gameMenu?.showLoading();
                fetch('/api/native/launch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ core: gameData.core, rom: gameData.romSource })
                }).then(r => r.json()).then(result => {
                    if (!result.ok) {
                        console.error('Native launch failed:', result.error);
                        gameMenu?.hideLoading();
                        gameMenu?.show();
                    }
                    // If ok, kiosk stops â†’ this page dies â†’ RetroArch takes over
                }).catch(e => {
                    console.error('Native launch error:', e);
                    gameMenu?.hideLoading();
                    gameMenu?.show();
                });
                return;
            }

            // Persist settings to localStorage (works for both screen and controller-initiated games)
            if (gameData.gameHeight != null) {
                localStorage.setItem('retrobox_gameHeight', gameData.gameHeight);
            }
            if (gameData.threads != null) {
                localStorage.setItem('retrobox_threads', gameData.threads);
            }

            pendingROM = {
                source: gameData.romSource,
                name: gameData.romName.split('.').slice(0, -1).join('.'),
                core: gameData.core,
                biosSource: gameData.biosSource,
                gameHeight: gameData.gameHeight || null,
                threads: gameData.threads || false,
                resolution: gameData.resolution || null,
                webgl2: gameData.webgl2 !== undefined ? gameData.webgl2 : null
            };
            setState(State.LOADING);
            initializeEmulator();
        }

        function resetToGameMenu() {
            saveState(0);

            // Wait for save to complete before cleanup
            setTimeout(() => {
                // Clean up emulator if it exists
                try {
                    if (window.EJS_emulator) {
                        window.EJS_emulator.pause?.();
                        // Close audio context
                        const ctx = window.EJS_emulator.Module?.AL?.currentCtx?.audioCtx;
                        if (ctx && ctx.state !== 'closed') ctx.close().catch(() => {});
                        // Lose WebGL contexts to free GPU memory
                        const canvases = document.querySelectorAll('#game canvas');
                        canvases.forEach(c => {
                            const gl = c.getContext('webgl2') || c.getContext('webgl');
                            if (gl?.getExtension) gl.getExtension('WEBGL_lose_context')?.loseContext();
                        });
                        window.EJS_emulator = null;
                    }
                } catch (e) { console.warn('Emulator cleanup error:', e); }

                // Remove loader script to stop any pending load
                if (loaderScript) {
                    loaderScript.remove();
                    loaderScript = null;
                }

                // Remove all EmulatorJS-injected scripts to prevent "already declared" errors
                const ejsScripts = document.querySelectorAll('script[src*="EmulatorJS/data/"]');
                ejsScripts.forEach(s => s.remove());

                // Clear global EmulatorJS identifiers to allow re-declaration
                const ejsIdentifiers = ['EJS_CommandHandler', 'HistoryManager', 'EmulatorJS', 'EJS_STORAGE',
                    'GamepadHandler', 'EJS_GameManager', 'EJSCompression'];
                ejsIdentifiers.forEach(key => { try { delete window[key]; } catch {} });

                // Clear global EmulatorJS config to prevent stale state
                const ejsGlobals = ['EJS_player', 'EJS_gameUrl', 'EJS_gameName', 'EJS_core', 'EJS_biosUrl',
                    'EJS_ready', 'EJS_onGameStart', 'EJS_onCommand', 'EJS_startOnLoaded', 'EJS_cheats'];
                ejsGlobals.forEach(key => { try { delete window[key]; } catch {} });

                const container = document.querySelector('.game-container');
                const gameEl = document.getElementById('game');
                gameEl.innerHTML = '';
                gameEl.style.height = gameEl.style.width = '';
                container.style.height = container.style.width = '';

                pendingROM = null;
                isPaused = false;
                setState(State.IDLE);
                broadcastToControllers({ type: 'stateUpdate', state: 'game-selection', gameName: null, isPaused: false });
            }, 1000);
        }

        async function saveState(slot) {
            if (!window.EJS_emulator?.gameManager || !window.EJS_emulator?.storage?.states) return;
            try {
                const state = window.EJS_emulator.gameManager.getState();
                const key = window.EJS_emulator.getBaseFileName() + `.state${slot}`;
                await window.EJS_emulator.storage.states.put(key, state);
                window.EJS_emulator.displayMessage?.(window.EJS_emulator.localization?.("SAVED STATE TO BROWSER") || "State saved");
            } catch (e) { console.warn('Save state failed:', e); }
        }

        async function loadState(slot) {
            if (!window.EJS_emulator?.gameManager || !window.EJS_emulator?.storage?.states) return;
            try {
                const key = window.EJS_emulator.getBaseFileName() + `.state${slot}`;
                const state = await window.EJS_emulator.storage.states.get(key);
                if (state) {
                    window.EJS_emulator.gameManager.loadState(state);
                    window.EJS_emulator.displayMessage?.(window.EJS_emulator.localization?.("LOADED STATE FROM BROWSER") || "State loaded");
                } else {
                    window.EJS_emulator.displayMessage?.("No saved state found");
                }
            } catch (e) { console.warn('Load state failed:', e); }
        }

        let fpsVisible = false; // Track FPS state (starts hidden by default)
        function toggleFPS() {
            if (!window.EJS_emulator?.gameManager) return;
            fpsVisible = !fpsVisible;
            const newValue = fpsVisible ? "show" : "hide";
            window.EJS_emulator.gameManager.setVariable("fps", newValue);
            window.EJS_emulator.displayMessage?.(`FPS: ${fpsVisible ? "ON" : "OFF"}`);
            console.log('FPS toggled:', newValue);
        }

        // Audio unlock
        let hasUserInteraction = false;
        function hideAudioIndicator() { document.getElementById('audioMutedIndicator').classList.remove('visible'); }
        function showAudioIndicator() { document.getElementById('audioMutedIndicator').classList.add('visible'); }

        ['click', 'touchstart', 'keydown', 'mousedown'].forEach(evt => {
            document.addEventListener(evt, function onInteraction() {
                hasUserInteraction = true;
                hideAudioIndicator();
                const ctx = window.EJS_emulator?.Module?.AL?.currentCtx?.audioCtx;
                if (ctx?.state === 'suspended') ctx.resume().then(() => window.EJS_emulator?.setVolume?.(1));
            }, { passive: true });
        });

        function applyGameHeight(heightPercent) {
            const container = document.querySelector('.game-container');
            const gameEl = document.getElementById('game');
            if (heightPercent) {
                container.style.height = heightPercent + 'vh';
                container.style.width = '100%';
                gameEl.style.height = gameEl.style.width = '100%';
            } else {
                container.style.height = container.style.width = '100%';
            }
        }

        async function initializeEmulator() {
            window.EJS_player = '#game';
            window.EJS_pathtodata = 'EmulatorJS/data/';
            window.EJS_startOnLoaded = true;
            window.EJS_volume = 1;
            window.EJS_DEBUG_XX = true;
            // Auto-enable threads for CPU-heavy cores (N64 cached interpreter)
            const autoThreadCores = ['n64', 'mupen64plus_next'];
            window.EJS_threads = pendingROM?.threads || autoThreadCores.includes(pendingROM?.core) || false;
            window.EJS_EXPERIMENTAL_NETPLAY = true;
            // Default gamepad mappings for all 4 players
            const gamepadControls = {
                0:  { value2: 'BUTTON_2' },          // Cross / A
                1:  { value2: 'BUTTON_4' },          // Circle / B
                3:  { value2: 'START' },              // Options / Start
                4:  { value2: 'DPAD_UP' },
                5:  { value2: 'DPAD_DOWN' },
                6:  { value2: 'DPAD_LEFT' },
                7:  { value2: 'DPAD_RIGHT' },
                10: { value2: 'LEFT_TOP_SHOULDER' },  // L1
                11: { value2: 'RIGHT_TOP_SHOULDER' }, // R1
                12: { value2: 'LEFT_BOTTOM_SHOULDER' }, // L2
                16: { value2: 'LEFT_STICK_X:+1' },
                17: { value2: 'LEFT_STICK_X:-1' },
                18: { value2: 'LEFT_STICK_Y:+1' },
                19: { value2: 'LEFT_STICK_Y:-1' },
                20: { value2: 'RIGHT_STICK_X:+1' },
                21: { value2: 'RIGHT_STICK_X:-1' },
                22: { value2: 'RIGHT_STICK_Y:+1' },
                23: { value2: 'RIGHT_STICK_Y:-1' },
            };
            window.EJS_defaultControls = {
                0: gamepadControls,
                1: gamepadControls,
                2: gamepadControls,
                3: gamepadControls,
            };
            window.EJS_backgroundBlur = false;
            window.EJS_backgroundColor = '#1a1a1a';
            window.EJS_defaultOptions = { "save-state-location": "browser", "fps": "hide" };

            // N64 performance optimizations (mupen64plus_next)
            if (pendingROM?.core === 'n64' || pendingROM?.core === 'mupen64plus_next') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    // CPU
                    "mupen64plus-cpucore": "cached_interpreter",
                    "mupen64plus-CountPerOp": "0",
                    // GPU â€” GLideN64 + HLE RSP
                    "mupen64plus-RSP": "hle",
                    "mupen64plus-rdp-plugin": "gliden64",
                    // Resolution â€” 2x native + FXAA
                    "mupen64plus-EnableNativeResFactor": "2",
                    "mupen64plus-FXAA": "1",
                    // Framebuffer â€” minimize copies
                    "mupen64plus-EnableFBEmulation": "True",
                    "mupen64plus-EnableCopyColorToRDRAM": "Off",
                    "mupen64plus-EnableCopyDepthToRDRAM": "Off",
                    // Visuals
                    "mupen64plus-EnableLODEmulation": "True",
                    "mupen64plus-EnableHWLighting": "True",
                    "mupen64plus-EnableShadersStorage": "True",
                    "mupen64plus-BilinearMode": "standard",
                    "mupen64plus-MultiSampling": "0",
                    // Aspect ratio
                    "mupen64plus-aspect": "4:3",
                };
            }

            // // Enable multitap for multiplayer games
            // if (pendingROM?.core === 'psx') {
            //     window.EJS_defaultOptions["pcsx_rearmed_multitap"] = "port 1";
            // }

            // Enable optimizations for PS1 cores (pcsx_rearmed and mednafen_psx_hw)
            if (pendingROM?.core === 'psx' || pendingROM?.core === 'pcsx_rearmed') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    // "pcsx_rearmed_multitap": "port 1",
                    // Performance optimizations
                    "pcsx_rearmed_duping_enable": "enabled",
                    "pcsx_rearmed_gpu_thread_rendering": "async",
                    "pcsx_rearmed_async_cd": "async",
                    "pcsx_rearmed_drc": "enabled",
                    // Visual improvements
                    "pcsx_rearmed_dithering": "enabled",
                    "shader": "2xScaleHQ.glslp"
                };
            }
            if (pendingROM?.core === 'mednafen_psx_hw') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    // Graphics enhancements (resolution set dynamically via RESOLUTION_OPTIONS)
                    "beetle_psx_hw_pgxp_mode": "memory only",
                    "beetle_psx_hw_pgxp_texture": "enabled",
                    "beetle_psx_hw_filter": "bilinear",
                    "beetle_psx_hw_dither_mode": "disabled",
                    // Performance
                    "beetle_psx_hw_cd_fastload": "2x"
                };
            }
            // Apply resolution and WebGL2 settings from game data or localStorage
            if (pendingROM?.core) {
                const resConfig = RESOLUTION_OPTIONS[pendingROM.core];
                if (resConfig) {
                    // Resolution
                    let resValue = pendingROM.resolution;
                    if (!resValue) {
                        try {
                            const saved = JSON.parse(localStorage.getItem('retrobox_resolution') || '{}');
                            resValue = saved[pendingROM.core];
                        } catch {}
                    }
                    if (resValue) {
                        window.EJS_defaultOptions[resConfig.key] = resValue;
                        console.log(`Resolution: ${resConfig.key} = ${resValue}`);
                    }

                    // WebGL2 (defaults to true for cores with resolution options)
                    let webgl2 = pendingROM.webgl2;
                    if (webgl2 === undefined || webgl2 === null) {
                        try {
                            const saved = JSON.parse(localStorage.getItem('retrobox_webgl2') || '{}');
                            webgl2 = saved[pendingROM.core];
                        } catch {}
                    }
                    if (webgl2 === undefined || webgl2 === null) webgl2 = true; // default true
                    if (!webgl2) {
                        window.EJS_defaultOptions["webgl2Enabled"] = "disabled";
                        console.log('WebGL2: disabled');
                    } else {
                        console.log('WebGL2: enabled');
                    }
                }
            }

            if (pendingROM?.gameHeight) applyGameHeight(pendingROM.gameHeight);
            window.EJS_disableAutoLang = true;
            window.EJS_language = "en";

            if (!pendingROM) { console.error('No ROM'); setState(State.IDLE); return; }
            window.EJS_gameName = pendingROM.name;
            window.EJS_gameUrl = pendingROM.source;
            window.EJS_core = pendingROM.core;
            if (pendingROM.biosSource) window.EJS_biosUrl = pendingROM.biosSource;

            // Load cheats if available
            try {
                const cheatRes = await fetch(`/api/cheats?game=${encodeURIComponent(pendingROM.name)}&system=${encodeURIComponent(pendingROM.core)}`);
                if (cheatRes.ok) {
                    const cheatData = await cheatRes.json();
                    if (cheatData.cheats?.length) {
                        window.EJS_cheats = cheatData.cheats;
                        console.log(`[cheats] Loaded ${cheatData.cheats.length} cheats for ${pendingROM.name}`);
                    }
                }
            } catch (e) { console.log('[cheats] Failed to load:', e.message); }

            window.EJS_Buttons = {
                playPause: true, restart: true, mute: true, settings: true, fullscreen: true,
                saveState: true, loadState: true, screenRecord: true, gamepad: true, cheat: true,
                volume: true, saveSavFiles: true, loadSavFiles: true, quickSave: true, quickLoad: true,
                screenshot: true, cacheManager: true, exitEmulation: false, netplay: true,
                resetToMenu: { visible: true, displayName: "Menu", icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>', callback: resetToGameMenu }
            };

            window.EJS_ready = function() {
                // Guard: only proceed if we're still loading this game
                if (currentState !== State.LOADING || !pendingROM) {
                    console.log('EmulatorJS ready but load was cancelled');
                    return;
                }
                console.log('EmulatorJS ready');
                function autoStart() {
                    if (currentState !== State.LOADING) return; // Cancelled
                    if (window.EJS_emulator?.started) return;
                    const btn = document.querySelector('#game .ejs_start_button');
                    if (btn?.offsetParent) { btn.click(); return; }
                    setTimeout(autoStart, 200);
                }
                autoStart();
            };

            window.EJS_onGameStart = function() {
                // Guard: only proceed if we're still expecting this game to start
                if (currentState !== State.LOADING || !pendingROM) {
                    console.log('Game start callback but load was cancelled');
                    return;
                }
                console.log('Game started');
                setState(State.PLAYING);
                if (pendingROM?.gameHeight) applyGameHeight(pendingROM.gameHeight);
                setTimeout(() => {
                    if (currentState !== State.PLAYING) return; // State changed
                    const ctx = window.EJS_emulator?.Module?.AL?.currentCtx?.audioCtx;
                    if (ctx?.state === 'suspended') {
                        if (hasUserInteraction) ctx.resume().catch(() => showAudioIndicator());
                        else showAudioIndicator();
                    }
                }, 500);
                // Auto-load previous save state if "Load on start" setting is enabled
                if (localStorage.getItem('retrobox_loadOnStart') === 'true') {
                    setTimeout(() => {
                        if (currentState === State.PLAYING) loadState(0);
                    }, 2500);
                }
            };

            window.EJS_onCommand = function(evt) {
                const m = evt.method;
                if (m === 'input.simulate' && evt.params?.button === 19 && (evt.params.state === 'pressed' || evt.params.value === 1)) {
                    syncPauseUI(!isPaused);
                }
                if (m === 'control.toggle-pause' || m === 'control.togglePause' || m === 'togglePause') {
                    syncPauseUI(!isPaused);
                } else if (m === 'control.pause') {
                    syncPauseUI(true);
                } else if (m === 'control.play' || m === 'control.resume') {
                    syncPauseUI(false);
                }
            };

            // If EmulatorJS scripts were already loaded, we must reload the page
            // because const/let declarations cannot be re-declared
            if (ejsScriptsLoaded) {
                // Can only persist URL sources, not File objects
                if (typeof pendingROM.source !== 'string') {
                    alert('Cannot switch games with uploaded files. Please select from presets or use a URL.');
                    setState(State.IDLE);
                    return;
                }
                // Store game data in sessionStorage for reload
                sessionStorage.setItem('retrobox_pendingGame', JSON.stringify({
                    source: pendingROM.source,
                    name: pendingROM.name,
                    core: pendingROM.core,
                    biosSource: typeof pendingROM.biosSource === 'string' ? pendingROM.biosSource : null,
                    gameHeight: pendingROM.gameHeight,
                    threads: pendingROM.threads,
                    resolution: pendingROM.resolution,
                    webgl2: pendingROM.webgl2
                }));
                window.location.reload();
                return;
            }

            // Remove any existing loader script before adding new one
            if (loaderScript) {
                loaderScript.remove();
                loaderScript = null;
            }

            loaderScript = document.createElement('script');
            loaderScript.src = 'EmulatorJS/data/loader.js';
            loaderScript.onload = () => { ejsScriptsLoaded = true; };
            document.body.appendChild(loaderScript);
        }

        // ============================================
        // INITIALIZE
        // ============================================
        init();

        // ============================================
        // GAME MENU LOADER
        // ============================================
        (async () => {
            gameMenu = await loadGameMenuComponent(loadROM, resetToGameMenu);
            // Listen for debug mode changes from game-menu
            gameMenu?.addEventListener('debugmodechange', (e) => {
                _setDebugMode(e.detail.enabled);
                console.log('Debug mode:', e.detail.enabled ? 'enabled' : 'disabled');
            });
        })();
    </script>
</body>
</html>
