<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroBox</title>
    <script>
        // Disable WakeLock by intercepting errors
        const originalRequest = navigator.wakeLock?.request;
        if (originalRequest) {
            navigator.wakeLock.request = async function(...args) {
                try { return await originalRequest.apply(this, args); }
                catch (e) {
                    console.log('WakeLock error caught:', e.message);
                    return { released: false, type: args[0], release: async () => {}, addEventListener: () => {}, removeEventListener: () => {} };
                }
            };
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #1a1a1a; font-family: Arial, sans-serif; }
        body { display: flex; justify-content: center; align-items: center; }
        .game-container { width: 100%; height: 100%; border-radius: 8px; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; }
        #game { width: 100%; height: 100%; }

        #loadingOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .loading { color: #fff; text-align: center; padding: 20px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; z-index: 100; }
        .loading-spinner { margin: 20px auto; width: 50px; height: 50px; border: 3px solid rgba(255, 255, 255, 0.3); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .controllers { position: fixed; top: max(10px, 1.5vh); right: max(10px, 1.5vw); z-index: 1000; display: flex; gap: max(4px, 0.8vmin); }
        .controller-dot { width: max(6px, 1vmin); height: max(6px, 1vmin); border-radius: 50%; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15); transition: all 0.3s; position: relative; }
        .controller-dot.active { width: max(10px, 1.5vmin); height: max(10px, 1.5vmin); border: none; animation: pulse 2s ease-in-out infinite; }
        .controller-dot.active.player-0 { background: #4CAF50; box-shadow: 0 0 max(6px, 1vmin) rgba(76, 175, 80, 0.5); }
        .controller-dot.active.player-1 { background: #2196F3; box-shadow: 0 0 max(6px, 1vmin) rgba(33, 150, 243, 0.5); }
        .controller-dot.active.player-2 { background: #9C27B0; box-shadow: 0 0 max(6px, 1vmin) rgba(156, 39, 176, 0.5); }
        .controller-dot.active.player-3 { background: #FFC107; box-shadow: 0 0 max(6px, 1vmin) rgba(255, 193, 7, 0.5); }
        .controller-dot.reserved { width: max(8px, 1.2vmin); height: max(8px, 1.2vmin); opacity: 0.4; animation: none; }
        .controller-dot.reserved.player-0 { background: #4CAF50; }
        .controller-dot.reserved.player-1 { background: #2196F3; }
        .controller-dot.reserved.player-2 { background: #9C27B0; }
        .controller-dot.reserved.player-3 { background: #FFC107; }
        .controller-dot .ping { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); font-size: 8px; color: rgba(255,255,255,0.5); white-space: nowrap; margin-top: 2px; font-family: monospace; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.8; } }

        .qr-container { position: fixed; top: 20px; left: 20px; z-index: 999; text-align: center; background: rgba(0, 0, 0, 0.9); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); transition: opacity 0.3s, transform 0.3s; display: flex; flex-direction: column; align-items: center; }
        .qr-container.hidden { opacity: 0; transform: translateY(-20px); pointer-events: none; }
        .qr-code-display { background: white; padding: 10px; border-radius: 4px; display: inline-block; margin: 5px 0; }
        .qr-code-display img, .qr-code-display canvas { display: block; width: 100% !important; height: 100% !important; }
        .qr-text { color: rgba(255, 255, 255, 0.8); font-size: max(12px, min(2.5vw, 2.5vh)); margin-bottom: 8px; font-weight: 500; }
        .qr-url { color: #4a9eff; font-family: monospace; margin-top: 8px; word-break: break-all; text-decoration: none; transition: color 0.2s; display: block; text-align: center; line-height: 1.3; }
        .qr-url:hover { color: #7bc0ff; text-decoration: underline; }

        .status { position: fixed; bottom: max(8px, 1.5vh); right: max(8px, 1.5vw); padding: max(4px, 0.8vmin) max(8px, 1.5vmin); border-radius: max(3px, 0.5vmin); font-size: max(10px, min(2vw, 2vh, 14px)); z-index: 1001; transition: opacity 0.3s, visibility 0.3s; opacity: 0.7; }
        .status.hidden { opacity: 0; visibility: hidden; }
        .status.connecting { background: #FF9800; color: #000; }
        .status.connected { background: #4CAF50; color: #fff; }
        .status.error { background: #f44336; color: #fff; }

        #audioMutedIndicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.9); color: white; padding: 12px 24px; border-radius: 8px; font-size: 16px; z-index: 3000; cursor: pointer; display: none; align-items: center; gap: 10px; border: 1px solid rgba(255, 255, 255, 0.2); }
        #audioMutedIndicator.visible { display: flex; }
        #audioMutedIndicator .icon { font-size: 24px; }
        #audioMutedIndicator .hint { font-size: 12px; opacity: 0.6; }

        #pauseOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.4); z-index: 998; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #pauseOverlay.visible { opacity: 1; }

        #playerStatus { position: fixed; top: 20vh; left: 50%; transform: translateX(-50%); display: flex; gap: max(8px, 1.5vmin); align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.7); padding: max(8px, 1vmin) max(16px, 2vmin); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); z-index: 1001; transition: opacity 0.3s, visibility 0.3s; }
        #playerStatus.hidden { opacity: 0; visibility: hidden; }
        .player-indicator { display: flex; align-items: center; gap: max(4px, 0.6vmin); color: rgba(255, 255, 255, 0.6); font-size: max(11px, 1.4vmin); }
        .player-indicator .dot { width: max(8px, 1.2vmin); height: max(8px, 1.2vmin); border-radius: 50%; background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.2); }
        .player-indicator.connected .dot { animation: pulse 2s ease-in-out infinite; border: none; }
        .player-indicator.connected { color: rgba(255, 255, 255, 0.9); }
        .player-indicator.reserved .dot { opacity: 0.5; }
        .player-indicator .dot.player-0 { background: #4CAF50; box-shadow: 0 0 max(6px, 1vmin) rgba(76, 175, 80, 0.4); }
        .player-indicator .dot.player-1 { background: #2196F3; box-shadow: 0 0 max(6px, 1vmin) rgba(33, 150, 243, 0.4); }
        .player-indicator .dot.player-2 { background: #9C27B0; box-shadow: 0 0 max(6px, 1vmin) rgba(156, 39, 176, 0.4); }
        .player-indicator .dot.player-3 { background: #FFC107; box-shadow: 0 0 max(6px, 1vmin) rgba(255, 193, 7, 0.4); }
    </style>
</head>
<body>
    <div class="qr-container" id="qrContainer">
        <div class="qr-text">Scan to connect</div>
        <div class="qr-code-display" id="qrCodeDisplay"></div>
        <a class="qr-url" id="qrUrl" href="#" target="_blank" rel="noopener"></a>
    </div>
    <div class="game-container"><div id="game"></div></div>
    <div id="loadingOverlay"><div class="loading"><div class="loading-spinner"></div></div></div>
    <div id="audioMutedIndicator">
        <span class="icon">ðŸ”‡</span>
        <div><div class="text">Audio muted</div><div class="hint">Press any key or tap to enable</div></div>
    </div>
    <div class="controllers" id="controllers"></div>
    <div class="status connecting" id="status">Connecting...</div>
    <div id="pauseOverlay"></div>
    <div id="playerStatus" class="hidden"></div>
    <game-menu id="gameMenu" mode="screen"></game-menu>

    <script type="text/javascript">
        // ============================================
        // CONSTANTS
        // ============================================
        const HEARTBEAT_INTERVAL = 3000;
        const GRACE_PERIOD = 7500;

        // ============================================
        // STATE
        // ============================================
        const State = { IDLE: 'game-selection', LOADING: 'game-pending', PLAYING: 'game-ready' };
        let currentState = State.IDLE;
        let pendingROM = null;
        let isPaused = false;
        let gameMenu = null;

        let ws = null;
        let screenId = null;
        let heartbeatInterval = null;
        let loaderScript = null; // Track the loader script element

        // ============================================
        // WEBRTC P2P STATE
        // ============================================
        const peers = new Map(); // controllerId -> { pc, channel, playerNum, rtt }
        const pendingRemoval = new Map(); // controllerId -> timeout
        const echoBuf = new Uint32Array(1); // Pre-allocated echo buffer (Worker 3 pattern)
        let iceCandidateBuffers = new Map(); // controllerId -> [candidates]

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        function getStateInfo() {
            return { type: 'stateUpdate', state: currentState, gameName: pendingROM?.name, core: pendingROM?.core, isPaused };
        }

        function setState(newState) {
            if (currentState === newState) return;
            console.log(`State: ${currentState} -> ${newState}`);
            currentState = newState;
            updateScreenUI();
            broadcastToControllers(getStateInfo());
        }

        function broadcastToControllers(msg) {
            if (ws?.readyState === WebSocket.OPEN) ws.send(JSON.stringify(msg));
        }

        function updateScreenUI() {
            switch (currentState) {
                case State.IDLE:
                    gameMenu?.show(); hidePauseOverlay(); showQRCode(); showPlayerStatus(); showStatus(); break;
                case State.LOADING:
                    gameMenu?.setLoadingText(`Loading ${pendingROM?.name || 'game'}...`);
                    gameMenu?.showLoading(); hidePauseOverlay(); hideQRCode(); hidePlayerStatus(); hideStatus(); break;
                case State.PLAYING:
                    gameMenu?.hide(); hidePlayerStatus(); hideStatus();
                    if (isPaused) { showPauseOverlay(); showQRCode(); } else { hidePauseOverlay(); hideQRCode(); }
                    break;
            }
        }

        function showPlayerStatus() { document.getElementById('playerStatus').classList.remove('hidden'); }
        function hidePlayerStatus() { document.getElementById('playerStatus').classList.add('hidden'); }
        function showStatus() { document.getElementById('status').classList.remove('hidden'); }
        function hideStatus() { document.getElementById('status').classList.add('hidden'); }

        // ============================================
        // PAUSE
        // ============================================
        function syncPauseUI(paused) {
            if (currentState !== State.PLAYING) return;
            isPaused = paused;
            if (isPaused) { showPauseOverlay(); showQRCode(); } else { hidePauseOverlay(); hideQRCode(); }
            broadcastToControllers(getStateInfo());
        }

        function setPause(paused) {
            if (currentState !== State.PLAYING || isPaused === paused) return;
            if (paused) EJS_emulator?.pause?.(); else EJS_emulator?.play?.();
            syncPauseUI(paused);
        }

        function showPauseOverlay() { document.getElementById('pauseOverlay').classList.add('visible'); }
        function hidePauseOverlay() { document.getElementById('pauseOverlay').classList.remove('visible'); }

        // ============================================
        // WEBSOCKET
        // ============================================
        function updateStatus(status, text) {
            const el = document.getElementById('status');
            el.className = 'status ' + status;
            el.textContent = text;
        }

        function getWebSocketUrl() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            return `${protocol}//${window.location.host}/ws`;
        }

        function connectWebSocket() {
            if (ws?.readyState === WebSocket.OPEN) return;

            updateStatus('connecting', 'Connecting...');
            ws = new WebSocket(getWebSocketUrl());

            ws.onopen = () => {
                console.log('WebSocket connected, registering as screen:', screenId);
                ws.send(JSON.stringify({ type: 'register-screen', screenId }));

                clearInterval(heartbeatInterval);
                heartbeatInterval = setInterval(() => {
                    if (ws?.readyState === WebSocket.OPEN) ws.send(JSON.stringify({ type: 'heartbeat' }));
                }, HEARTBEAT_INTERVAL);
            };

            ws.onmessage = e => handleMessage(JSON.parse(e.data));

            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                updateStatus('connecting', 'Reconnecting...');
                clearInterval(heartbeatInterval);
                setTimeout(connectWebSocket, 2000);
            };

            ws.onerror = err => {
                console.error('WebSocket error:', err);
                updateStatus('error', 'Connection error');
            };
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'registered':
                    console.log('Screen registered:', msg.screenId);
                    updateStatus('connected', 'Ready: ' + screenId);
                    break;

                case 'controller-connected':
                    handleControllerConnected(msg.controllerId, msg.playerNum);
                    break;

                case 'controller-disconnected':
                    handleControllerDisconnected(msg.controllerId, msg.playerNum);
                    break;

                case 'webrtc-offer':
                    handleWebRTCOffer(msg.from, msg.offer);
                    break;

                case 'ice-candidate':
                    handleRemoteIceCandidate(msg.from, msg.candidate);
                    break;

                case 'heartbeat-ack':
                    break;

                case 'startGame':
                    if (msg.gameData) loadROM(msg.gameData);
                    break;

                case 'resetToMenu':
                    resetToGameMenu();
                    break;

                case 'hardRefresh':
                    console.log('Hard refresh requested by controller');
                    window.location.reload();
                    break;

                case 'toggleFPS':
                    toggleFPS();
                    break;

                case 'saveState':
                    saveState(msg.slot);
                    break;

                case 'loadState':
                    loadState(msg.slot);
                    break;

                default:
                    // Handle input from controller (WebSocket fallback)
                    if (currentState === State.PLAYING && EJS_emulator?.handler && msg.method) {
                        try { EJS_emulator.handler.exec(msg.method, msg.params); }
                        catch (e) { console.error('Input error:', e); }
                    }
            }
        }

        // ============================================
        // WEBRTC P2P (Screen side)
        // ============================================
        function handleControllerConnected(controllerId, playerNum) {
            console.log('Controller connected:', controllerId, 'Player', playerNum + 1);

            // Cancel pending removal if reconnecting
            if (pendingRemoval.has(controllerId)) {
                clearTimeout(pendingRemoval.get(controllerId));
                pendingRemoval.delete(controllerId);
                console.log('[WebRTC] Reconnection within grace period, restored Player', playerNum + 1);
            }

            // Track peer (P2P connection created on offer)
            if (!peers.has(controllerId)) {
                peers.set(controllerId, { pc: null, channel: null, playerNum, rtt: 0 });
            }

            updateControllerDisplay();
            ws.send(JSON.stringify({ ...getStateInfo(), targetController: controllerId }));
        }

        function handleControllerDisconnected(controllerId, playerNum) {
            console.log('Controller disconnected:', controllerId, 'Player', playerNum + 1);

            // Start grace period for reconnection
            const timeout = setTimeout(() => {
                console.log('[WebRTC] Grace period expired for Player', playerNum + 1);
                const peer = peers.get(controllerId);
                if (peer?.pc) try { peer.pc.close(); } catch {}
                peers.delete(controllerId);
                pendingRemoval.delete(controllerId);
                iceCandidateBuffers.delete(controllerId);
                updateControllerDisplay();

                // Auto-pause when no controllers
                if (peers.size === 0 && currentState === State.PLAYING && !isPaused) {
                    console.log('No controllers, pausing...');
                    setPause(true);
                }
            }, GRACE_PERIOD);

            pendingRemoval.set(controllerId, timeout);
            updateControllerDisplay();
        }

        function getNextPlayerNum() {
            const used = new Set([...peers.values()].map(p => p.playerNum));
            for (let i = 0; i < 4; i++) if (!used.has(i)) return i;
            return peers.size;
        }

        function handleWebRTCOffer(controllerId, offer) {
            console.log('[WebRTC] Received offer from:', controllerId);

            let peer = peers.get(controllerId);
            if (!peer) {
                peer = { pc: null, channel: null, playerNum: getNextPlayerNum(), rtt: 0 };
                peers.set(controllerId, peer);
            }

            // Close existing connection if any
            if (peer.pc) try { peer.pc.close(); } catch {}

            const pc = new RTCPeerConnection({ iceServers: [] });
            peer.pc = pc;
            iceCandidateBuffers.set(controllerId, { buffer: [], remoteDescSet: false });

            pc.ondatachannel = e => {
                console.log('[WebRTC] DataChannel received from:', controllerId);
                const ch = e.channel;
                peer.channel = ch;
                ch.binaryType = 'arraybuffer';

                ch.onmessage = evt => handleP2PMessage(controllerId, evt.data);
                ch.onclose = () => console.log('[WebRTC] DataChannel closed:', controllerId);
                ch.onerror = err => console.error('[WebRTC] DataChannel error:', controllerId, err);
            };

            pc.onicecandidate = e => {
                if (e.candidate && ws?.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ice-candidate', to: controllerId, candidate: e.candidate }));
                }
            };

            pc.onconnectionstatechange = () => {
                console.log('[WebRTC] Connection state:', controllerId, pc.connectionState);
            };

            pc.setRemoteDescription(offer).then(() => {
                const iceData = iceCandidateBuffers.get(controllerId);
                if (iceData) {
                    iceData.remoteDescSet = true;
                    iceData.buffer.forEach(c => pc.addIceCandidate(c).catch(() => {}));
                    iceData.buffer = [];
                }
                return pc.createAnswer();
            }).then(answer => {
                pc.setLocalDescription(answer);
                ws.send(JSON.stringify({ type: 'webrtc-answer', to: controllerId, answer }));
                console.log('[WebRTC] Sent answer to:', controllerId);
            });
        }

        function handleRemoteIceCandidate(controllerId, candidate) {
            const peer = peers.get(controllerId);
            const iceData = iceCandidateBuffers.get(controllerId);

            if (!peer?.pc) return;

            if (iceData?.remoteDescSet) {
                peer.pc.addIceCandidate(candidate).catch(() => {});
            } else if (iceData) {
                iceData.buffer.push(candidate);
            }
        }

        function handleP2PMessage(controllerId, data) {
            const view = new DataView(data);
            const methodId = view.getUint8(0);
            const ts = view.getUint32(1, false);
            const peer = peers.get(controllerId);

            // Ping report (methodId=0)
            if (methodId === 0) {
                if (peer) peer.rtt = view.getUint16(5, true);
                updateControllerDisplay();
                return;
            }

            // Input messages (1=digital, 2=analog) - echo timestamp for RTT
            if (peer?.channel?.readyState === 'open') {
                echoBuf[0] = ts;
                peer.channel.send(echoBuf.buffer);
            }

            if (currentState !== State.PLAYING || !EJS_emulator?.handler) return;

            const button = view.getUint8(5);
            const player = peer?.playerNum ?? 0;
            const isAnalog = methodId === 2;
            const value = isAnalog ? view.getUint16(6, true) : view.getUint8(6);
            const state = isAnalog ? 'analog' : (value === 1 ? 'pressed' : 'released');

            try {
                EJS_emulator.handler.exec('input.simulate', { button, player, state, value });
            } catch (e) {
                console.error('P2P input error:', e);
            }
        }

        function updateControllerDisplay() {
            const container = document.getElementById('controllers');
            const playerStatus = document.getElementById('playerStatus');
            container.innerHTML = '';
            playerStatus.innerHTML = '';

            // Build player map from peers
            const playerMap = new Map();
            for (const [id, peer] of peers) {
                const isReserved = pendingRemoval.has(id);
                playerMap.set(peer.playerNum, { connected: !isReserved, rtt: peer.rtt });
            }

            for (let i = 0; i < 4; i++) {
                const info = playerMap.get(i);

                // Top-right corner dots with ping
                const dot = document.createElement('div');
                dot.className = 'controller-dot';
                if (info) {
                    dot.classList.add(info.connected ? 'active' : 'reserved', `player-${i}`);
                    if (info.connected && info.rtt > 0) {
                        const ping = document.createElement('span');
                        ping.className = 'ping';
                        ping.textContent = info.rtt + 'ms';
                        dot.appendChild(ping);
                    }
                }
                container.appendChild(dot);

                // Centered player status indicators
                const indicator = document.createElement('div');
                indicator.className = 'player-indicator';
                if (info?.connected) indicator.classList.add('connected');
                else if (info) indicator.classList.add('reserved');
                indicator.innerHTML = `<span class="dot ${info ? 'player-' + i : ''}"></span><span>P${i + 1}</span>`;
                playerStatus.appendChild(indicator);
            }
        }

        // Initialize
        async function init() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('host')) {
                screenId = urlParams.get('host').replace(/\./g, '-');
            } else {
                try {
                    const res = await fetch('/api/client-hostname');
                    const data = await res.json();
                    screenId = (data.hostname || data.ip || 'unknown').replace(/\./g, '-');
                } catch (e) {
                    console.warn('Could not fetch hostname, using random ID');
                    screenId = Array.from(crypto.getRandomValues(new Uint8Array(4)), b => b.toString(16).padStart(2, '0')).join('');
                }
            }
            console.log('Screen ID:', screenId);

            connectWebSocket();
            await generateQRCode();
            showQRCode();
            updateControllerDisplay();
            showPlayerStatus();
        }
        init();

        // ============================================
        // QR CODE
        // ============================================
        let qrCodeGenerated = false;
        let cachedControllerUrl = null;

        function calculateQRSize() {
            return Math.max(Math.floor(Math.min(window.innerWidth, window.innerHeight) / 4), 120);
        }

        async function getControllerUrl() {
            if (cachedControllerUrl) return cachedControllerUrl;
            let baseUrl;
            try {
                const res = await fetch('/api/network-info');
                const data = await res.json();
                if (data.url) baseUrl = `${data.url}/controller.html`;
            } catch(e) { console.warn('Network info error:', e); }
            if (!baseUrl) {
                const url = new URL(window.location.href);
                url.pathname = url.pathname.replace(/[^/]*$/, 'controller.html');
                baseUrl = url.toString();
            }
            cachedControllerUrl = baseUrl + '?screen=' + screenId;
            return cachedControllerUrl;
        }

        async function generateQRCode(force = false) {
            if (qrCodeGenerated && !force) return;
            const qrDisplay = document.getElementById('qrCodeDisplay');
            const qrUrl = document.getElementById('qrUrl');
            const url = await getControllerUrl();
            const size = calculateQRSize();

            qrDisplay.innerHTML = '';
            qrDisplay.style.width = qrDisplay.style.height = size + 'px';
            document.getElementById('qrContainer').style.maxWidth = (size + 40) + 'px';

            new QRCode(qrDisplay, { text: url, width: size, height: size, colorDark: '#000', colorLight: '#FFF', correctLevel: QRCode.CorrectLevel.H });
            qrUrl.textContent = url;
            qrUrl.href = url;

            const containerWidth = size + 20;
            qrUrl.style.fontSize = Math.max(12, Math.min(Math.floor(containerWidth / 12), 20)) + 'px';

            qrCodeGenerated = true;
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => qrCodeGenerated && generateQRCode(true), 150);
        });

        function showQRCode() { document.getElementById('qrContainer').classList.remove('hidden'); }
        function hideQRCode() { document.getElementById('qrContainer').classList.add('hidden'); }

        // ============================================
        // GAME LOADING
        // ============================================
        function loadROM(gameData) {
            pendingROM = {
                source: gameData.romSource,
                name: gameData.romName.split('.').slice(0, -1).join('.'),
                core: gameData.core,
                biosSource: gameData.biosSource,
                gameHeight: gameData.gameHeight || null
            };
            setState(State.LOADING);
            initializeEmulator();
        }

        function resetToGameMenu() {
            saveState(0);

            // Clean up emulator if it exists
            try {
                if (window.EJS_emulator) {
                    EJS_emulator.pause?.();
                    const ctx = EJS_emulator.Module?.AL?.currentCtx?.audioCtx;
                    if (ctx && ctx.state !== 'closed') ctx.close().catch(() => {});
                    window.EJS_emulator = null;
                }
            } catch (e) { console.warn('Emulator cleanup error:', e); }

            // Remove loader script to stop any pending load
            if (loaderScript) {
                loaderScript.remove();
                loaderScript = null;
            }

            // Clear global EmulatorJS config to prevent stale state
            const ejsGlobals = ['EJS_player', 'EJS_gameUrl', 'EJS_gameName', 'EJS_core', 'EJS_biosUrl',
                'EJS_ready', 'EJS_onGameStart', 'EJS_onCommand', 'EJS_startOnLoaded'];
            ejsGlobals.forEach(key => { try { delete window[key]; } catch {} });

            const container = document.querySelector('.game-container');
            const gameEl = document.getElementById('game');
            gameEl.innerHTML = '';
            gameEl.style.height = gameEl.style.width = '';
            container.style.height = container.style.width = '';

            pendingROM = null;
            isPaused = false;
            setState(State.IDLE);
            broadcastToControllers({ type: 'stateUpdate', state: 'game-selection', gameName: null, isPaused: false });
        }

        async function saveState(slot) {
            if (!EJS_emulator?.gameManager || !EJS_emulator?.storage?.states) return;
            try {
                const state = EJS_emulator.gameManager.getState();
                const key = EJS_emulator.getBaseFileName() + `.state${slot}`;
                await EJS_emulator.storage.states.put(key, state);
                EJS_emulator.displayMessage?.(EJS_emulator.localization?.("SAVED STATE TO BROWSER") || "State saved");
            } catch (e) { console.warn('Save state failed:', e); }
        }

        async function loadState(slot) {
            if (!EJS_emulator?.gameManager || !EJS_emulator?.storage?.states) return;
            try {
                const key = EJS_emulator.getBaseFileName() + `.state${slot}`;
                const state = await EJS_emulator.storage.states.get(key);
                if (state) {
                    EJS_emulator.gameManager.loadState(state);
                    EJS_emulator.displayMessage?.(EJS_emulator.localization?.("LOADED STATE FROM BROWSER") || "State loaded");
                } else {
                    EJS_emulator.displayMessage?.("No saved state found");
                }
            } catch (e) { console.warn('Load state failed:', e); }
        }

        let fpsVisible = false; // Track FPS state (starts hidden by default)
        function toggleFPS() {
            if (!EJS_emulator?.gameManager) return;
            fpsVisible = !fpsVisible;
            const newValue = fpsVisible ? "show" : "hide";
            EJS_emulator.gameManager.setVariable("fps", newValue);
            EJS_emulator.displayMessage?.(`FPS: ${fpsVisible ? "ON" : "OFF"}`);
            console.log('FPS toggled:', newValue);
        }

        // Audio unlock
        let hasUserInteraction = false;
        function hideAudioIndicator() { document.getElementById('audioMutedIndicator').classList.remove('visible'); }
        function showAudioIndicator() { document.getElementById('audioMutedIndicator').classList.add('visible'); }

        ['click', 'touchstart', 'keydown', 'mousedown'].forEach(evt => {
            document.addEventListener(evt, function onInteraction() {
                hasUserInteraction = true;
                hideAudioIndicator();
                const ctx = EJS_emulator?.Module?.AL?.currentCtx?.audioCtx;
                if (ctx?.state === 'suspended') ctx.resume().then(() => EJS_emulator?.setVolume?.(1));
            }, { passive: true });
        });

        function applyGameHeight(heightPercent) {
            const container = document.querySelector('.game-container');
            const gameEl = document.getElementById('game');
            if (heightPercent) {
                container.style.height = heightPercent + 'vh';
                container.style.width = '100%';
                gameEl.style.height = gameEl.style.width = '100%';
            } else {
                container.style.height = container.style.width = '100%';
            }
        }

        function initializeEmulator() {
            window.EJS_player = '#game';
            window.EJS_pathtodata = 'EmulatorJS/data/';
            window.EJS_startOnLoaded = true;
            window.EJS_volume = 1;
            window.EJS_DEBUG_XX = true;
            window.EJS_threads = true;
            window.EJS_EXPERIMENTAL_NETPLAY = true;
            window.EJS_defaultControls = false;
            window.EJS_backgroundBlur = false;
            window.EJS_backgroundColor = '#1a1a1a';
            window.EJS_defaultOptions = { "save-state-location": "browser", "fps": "hide" };

            // // Enable multitap for multiplayer games
            // if (pendingROM?.core === 'psx') {
            //     window.EJS_defaultOptions["pcsx_rearmed_multitap"] = "port 1";
            // }

            // Enable optimizations for PS1 cores (pcsx_rearmed and mednafen_psx_hw)
            if (pendingROM?.core === 'psx' || pendingROM?.core === 'pcsx_rearmed') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    // "pcsx_rearmed_multitap": "port 1",
                    // Performance optimizations
                    "pcsx_rearmed_duping_enable": "enabled",
                    "pcsx_rearmed_gpu_thread_rendering": "async",
                    "pcsx_rearmed_async_cd": "async",
                    "pcsx_rearmed_drc": "enabled",
                    // Visual improvements
                    "pcsx_rearmed_dithering": "enabled",
                    "shader": "2xScaleHQ.glslp"
                };
            }
            if (pendingROM?.core === 'mednafen_psx_hw') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    // Graphics enhancements
                    "beetle_psx_hw_internal_resolution": "2x",
                    "beetle_psx_hw_pgxp_mode": "memory only",
                    "beetle_psx_hw_pgxp_texture": "enabled",
                    "beetle_psx_hw_filter": "bilinear",
                    "beetle_psx_hw_dither_mode": "disabled",
                    // Performance
                    "beetle_psx_hw_cd_fastload": "2x"
                };
            }
            // N64: disable WebGL2 to avoid glMapBufferRange errors (uses legacy WebGL1 core)
            if (pendingROM?.core === 'n64' || pendingROM?.core === 'mupen64plus_next') {
                window.EJS_defaultOptions = {
                    ...window.EJS_defaultOptions,
                    "webgl2Enabled": "disabled"
                };
            }
            if (pendingROM?.gameHeight) applyGameHeight(pendingROM.gameHeight);
            window.EJS_disableAutoLang = true;
            window.EJS_language = "en";

            if (!pendingROM) { console.error('No ROM'); setState(State.IDLE); return; }
            window.EJS_gameName = pendingROM.name;
            window.EJS_gameUrl = pendingROM.source;
            window.EJS_core = pendingROM.core;
            if (pendingROM.biosSource) window.EJS_biosUrl = pendingROM.biosSource;

            window.EJS_Buttons = {
                playPause: true, restart: true, mute: true, settings: true, fullscreen: true,
                saveState: true, loadState: true, screenRecord: true, gamepad: true, cheat: true,
                volume: true, saveSavFiles: true, loadSavFiles: true, quickSave: true, quickLoad: true,
                screenshot: true, cacheManager: true, exitEmulation: false, netplay: true,
                resetToMenu: { visible: true, displayName: "Menu", icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>', callback: resetToGameMenu }
            };

            window.EJS_ready = function() {
                // Guard: only proceed if we're still loading this game
                if (currentState !== State.LOADING || !pendingROM) {
                    console.log('EmulatorJS ready but load was cancelled');
                    return;
                }
                console.log('EmulatorJS ready');
                function autoStart() {
                    if (currentState !== State.LOADING) return; // Cancelled
                    if (EJS_emulator?.started) return;
                    const btn = document.querySelector('#game .ejs_start_button');
                    if (btn?.offsetParent) { btn.click(); return; }
                    setTimeout(autoStart, 200);
                }
                autoStart();
            };

            window.EJS_onGameStart = function() {
                // Guard: only proceed if we're still expecting this game to start
                if (currentState !== State.LOADING || !pendingROM) {
                    console.log('Game start callback but load was cancelled');
                    return;
                }
                console.log('Game started');
                setState(State.PLAYING);
                if (pendingROM?.gameHeight) applyGameHeight(pendingROM.gameHeight);
                setTimeout(() => {
                    if (currentState !== State.PLAYING) return; // State changed
                    const ctx = EJS_emulator?.Module?.AL?.currentCtx?.audioCtx;
                    if (ctx?.state === 'suspended') {
                        if (hasUserInteraction) ctx.resume().catch(() => showAudioIndicator());
                        else showAudioIndicator();
                    }
                }, 500);
                setTimeout(() => {
                    if (currentState === State.PLAYING) loadState(0);
                }, 1500);
            };

            window.EJS_onCommand = function(evt) {
                const m = evt.method;
                if (m === 'input.simulate' && evt.params?.button === 19 && (evt.params.state === 'pressed' || evt.params.value === 1)) {
                    syncPauseUI(!isPaused);
                }
                if (m === 'control.toggle-pause' || m === 'control.togglePause' || m === 'togglePause') {
                    syncPauseUI(!isPaused);
                } else if (m === 'control.pause') {
                    syncPauseUI(true);
                } else if (m === 'control.play' || m === 'control.resume') {
                    syncPauseUI(false);
                }
            };

            // Remove any existing loader script before adding new one
            if (loaderScript) {
                loaderScript.remove();
                loaderScript = null;
            }

            loaderScript = document.createElement('script');
            loaderScript.src = 'EmulatorJS/data/loader.js';
            document.body.appendChild(loaderScript);
        }

        // ============================================
        // GAME MENU LOADER
        // ============================================
        async function loadGameMenuComponent() {
            try {
                const res = await fetch('game-menu.html');
                const html = await res.text();
                const doc = new DOMParser().parseFromString(html, 'text/html');
                const script = doc.querySelector('script[type="module"]');
                if (script) {
                    const el = document.createElement('script');
                    el.type = 'module';
                    el.textContent = script.textContent;
                    document.head.appendChild(el);
                    await customElements.whenDefined('game-menu');
                    gameMenu = document.getElementById('gameMenu');
                    gameMenu?.addEventListener('gamestart', e => loadROM(e.detail));
                    gameMenu?.addEventListener('resetToMenu', () => resetToGameMenu());
                }
            } catch(e) { console.error('Failed to load game menu:', e); }
        }
        loadGameMenuComponent();
    </script>
</body>
</html>
