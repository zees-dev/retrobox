<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RetroBox</title>
    <script>
        // Disable WakeLock by intercepting errors
        const originalRequest = navigator.wakeLock?.request;
        if (originalRequest) {
            navigator.wakeLock.request = async function(...args) {
                try { return await originalRequest.apply(this, args); }
                catch (e) {
                    console.log('WakeLock error caught:', e.message);
                    return { released: false, type: args[0], release: async () => {}, addEventListener: () => {}, removeEventListener: () => {} };
                }
            };
        }
    </script>
    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; background: #1a1a1a; font-family: Arial, sans-serif; }
        body { display: flex; justify-content: center; align-items: center; }
        .game-container { width: 100%; height: 100%; border-radius: 8px; overflow: hidden; position: relative; }
        #game { width: 100%; height: 100%; }

        #loadingOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); z-index: 2000; display: none; align-items: center; justify-content: center; }
        .loading { color: #fff; text-align: center; padding: 20px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; z-index: 100; }
        .loading-spinner { margin: 20px auto; width: 50px; height: 50px; border: 3px solid rgba(255, 255, 255, 0.3); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        .controllers { position: fixed; top: 15px; right: 15px; z-index: 1000; display: flex; gap: 8px; }
        .controller-dot { width: 6px; height: 6px; border-radius: 50%; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.15); transition: all 0.3s; }
        .controller-dot.active { width: 10px; height: 10px; border: none; animation: pulse 2s ease-in-out infinite; }
        .controller-dot.active.player-0 { background: #4CAF50; box-shadow: 0 0 10px rgba(76, 175, 80, 0.5); }
        .controller-dot.active.player-1 { background: #2196F3; box-shadow: 0 0 10px rgba(33, 150, 243, 0.5); }
        .controller-dot.active.player-2 { background: #9C27B0; box-shadow: 0 0 10px rgba(156, 39, 176, 0.5); }
        .controller-dot.active.player-3 { background: #FFC107; box-shadow: 0 0 10px rgba(255, 193, 7, 0.5); }
        .controller-dot.reserved { width: 8px; height: 8px; opacity: 0.4; animation: none; }
        .controller-dot.reserved.player-0 { background: #4CAF50; }
        .controller-dot.reserved.player-1 { background: #2196F3; }
        .controller-dot.reserved.player-2 { background: #9C27B0; }
        .controller-dot.reserved.player-3 { background: #FFC107; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.8; } }

        .qr-container { position: fixed; top: 20px; left: 20px; z-index: 999; text-align: center; background: rgba(0, 0, 0, 0.9); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); transition: opacity 0.3s, transform 0.3s; display: flex; flex-direction: column; align-items: center; }
        .qr-container.hidden { opacity: 0; transform: translateY(-20px); pointer-events: none; }
        .qr-code-display { background: white; padding: 10px; border-radius: 4px; display: inline-block; margin: 5px 0; }
        .qr-code-display img, .qr-code-display canvas { display: block; width: 100% !important; height: 100% !important; }
        .qr-text { color: rgba(255, 255, 255, 0.8); font-size: max(12px, min(2.5vw, 2.5vh)); margin-bottom: 8px; font-weight: 500; }
        .qr-url { color: #4a9eff; font-size: max(11px, min(2vw, 2vh)); font-family: monospace; margin-top: 8px; word-break: break-all; text-decoration: none; transition: color 0.2s; display: block; max-width: 100%; }
        .qr-url:hover { color: #7bc0ff; text-decoration: underline; }

        #audioMutedIndicator { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.9); color: white; padding: 12px 24px; border-radius: 8px; font-size: 16px; z-index: 3000; cursor: pointer; display: none; align-items: center; gap: 10px; border: 1px solid rgba(255, 255, 255, 0.2); }
        #audioMutedIndicator.visible { display: flex; }
        #audioMutedIndicator .icon { font-size: 24px; }
        #audioMutedIndicator .hint { font-size: 12px; opacity: 0.6; }

        #pauseOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.4); z-index: 998; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #pauseOverlay.visible { opacity: 1; }
    </style>
</head>
<body>
    <div class="qr-container" id="qrContainer">
        <div class="qr-text">Scan to connect</div>
        <div class="qr-code-display" id="qrCodeDisplay"></div>
        <a class="qr-url" id="qrUrl" href="#" target="_blank" rel="noopener"></a>
    </div>
    <div class="game-container"><div id="game"></div></div>
    <div id="loadingOverlay"><div class="loading"><div class="loading-spinner"></div></div></div>
    <div id="audioMutedIndicator">
        <span class="icon">ðŸ”‡</span>
        <div><div class="text">Audio muted</div><div class="hint">Press any key or tap to enable</div></div>
    </div>
    <div class="controllers" id="controllers"></div>
    <div id="pauseOverlay"></div>
    <game-menu id="gameMenu" mode="screen"></game-menu>

    <script type="text/javascript">
        // ============================================
        // CONSTANTS
        // ============================================
        const HEARTBEAT_INTERVAL = 3000;
        const HEARTBEAT_TIMEOUT = 8000;
        const PLAYER_RESERVATION_TIME = 10000;

        // ============================================
        // STATE
        // ============================================
        const State = { IDLE: 'game-selection', LOADING: 'game-pending', PLAYING: 'game-ready' };
        let currentState = State.IDLE;
        let pendingROM = null;
        let isPaused = false;
        let gameMenu = null;

        // PeerJS
        let peer;
        let controllerConnections = new Map();
        let heartbeatIntervals = new Map();
        let playerNumbers = new Map();

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        function getStateInfo() {
            return { type: 'stateUpdate', state: currentState, gameName: pendingROM?.name, core: pendingROM?.core, isPaused };
        }

        function setState(newState) {
            if (currentState === newState) return;
            console.log(`State: ${currentState} -> ${newState}`);
            currentState = newState;
            updateScreenUI();
            broadcastToControllers(getStateInfo());
        }

        function broadcastToControllers(msg) {
            controllerConnections.forEach(conn => { if (conn?.open) conn.send(msg); });
        }

        function updateScreenUI() {
            switch (currentState) {
                case State.IDLE:
                    gameMenu?.show();
                    hidePauseOverlay();
                    showQRCode();
                    break;
                case State.LOADING:
                    gameMenu?.setLoadingText(`Loading ${pendingROM?.name || 'game'}...`);
                    gameMenu?.showLoading();
                    hidePauseOverlay();
                    hideQRCode();
                    break;
                case State.PLAYING:
                    gameMenu?.hide();
                    if (isPaused) { showPauseOverlay(); showQRCode(); }
                    else { hidePauseOverlay(); hideQRCode(); }
                    break;
            }
        }

        // ============================================
        // PAUSE
        // ============================================
        // Update UI only (used when EJS already handled the pause/play)
        function syncPauseUI(paused) {
            if (currentState !== State.PLAYING) return;
            isPaused = paused;
            if (isPaused) { showPauseOverlay(); showQRCode(); }
            else { hidePauseOverlay(); hideQRCode(); }
            broadcastToControllers(getStateInfo());
        }

        // Programmatic pause (calls emulator + updates UI)
        function setPause(paused) {
            if (currentState !== State.PLAYING || isPaused === paused) return;
            if (paused) EJS_emulator?.pause?.();
            else EJS_emulator?.play?.();
            syncPauseUI(paused);
        }

        function showPauseOverlay() { document.getElementById('pauseOverlay').classList.add('visible'); }
        function hidePauseOverlay() { document.getElementById('pauseOverlay').classList.remove('visible'); }

        // ============================================
        // PEERJS
        // ============================================
        function initializePeer() {
            peer = new Peer('emulator-screen', { config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] } });
            peer.on('open', id => console.log('Screen ready:', id));
            peer.on('connection', handleControllerConnection);
            peer.on('error', err => {
                console.error('Peer error:', err);
                if (err.type === 'unavailable-id') setTimeout(() => peer.reconnect(), 5000);
            });
            peer.on('disconnected', () => { console.log('Reconnecting...'); peer.reconnect(); });
        }

        function handleControllerConnection(conn) {
            const id = conn.peer;
            conn.on('open', () => {
                // Clean up existing connection if reconnecting
                const existing = controllerConnections.get(id);
                if (existing) {
                    try { existing.close(); } catch(e) {}
                    clearInterval(heartbeatIntervals.get(id));
                }

                controllerConnections.set(id, conn);
                let playerNum = playerNumbers.get(id);
                if (playerNum === undefined) {
                    playerNum = getNextPlayerNumber();
                    playerNumbers.set(id, playerNum);
                }
                console.log('Controller connected:', id, 'Player', playerNum + 1);

                conn.send({ type: 'playerAssignment', playerNumber: playerNum });
                conn.send(getStateInfo());
                updateControllerDisplay();

                // Unified heartbeat monitoring
                let lastHeartbeat = Date.now();
                const interval = setInterval(() => {
                    if (!conn.open) { clearInterval(interval); return; }
                    if (Date.now() - lastHeartbeat > HEARTBEAT_TIMEOUT) {
                        console.log('Controller timeout:', id);
                        handleControllerDisconnect(id);
                    }
                }, HEARTBEAT_INTERVAL);
                heartbeatIntervals.set(id, interval);

                conn.on('data', data => handleControllerData(data, id, conn, () => lastHeartbeat = Date.now()));
                conn.on('close', () => handleControllerDisconnect(id));
                conn.on('error', () => handleControllerDisconnect(id));
            });
        }

        function handleControllerData(data, id, conn, updateHB) {
            if (data.type === 'heartbeat') {
                updateHB();
                conn.send({ type: 'ack', playerNumber: playerNumbers.get(id) });
                return;
            }
            if (data.type === 'startGame' && data.gameData) { loadROM(data.gameData); return; }
            if (data.type === 'resetToMenu') { resetToGameMenu(); return; }

            // Handle save/load state commands from controller (uses slot from controller)
            if (data.type === 'saveState') { saveState(data.slot); return; }
            if (data.type === 'loadState') { loadState(data.slot); return; }

            // Handle input in playing state
            if (currentState === State.PLAYING && EJS_emulator?.handler) {
                try {
                    if (data.method === 'input.simulate' && data.params) {
                        data.params.player = playerNumbers.get(id) || 0;
                    }
                    EJS_emulator.handler.exec(data.method, data.params);
                } catch (e) { console.error('Input error:', e); }
            }
        }

        function getNextPlayerNumber() {
            const used = Array.from(playerNumbers.values());
            for (let i = 0; i < 4; i++) if (!used.includes(i)) return i;
            return used.length;
        }

        function handleControllerDisconnect(id) {
            const conn = controllerConnections.get(id);
            if (!conn) return;
            try { conn.close(); } catch(e) {}
            clearInterval(heartbeatIntervals.get(id));
            heartbeatIntervals.delete(id);
            controllerConnections.delete(id);

            // Reserve player number for reconnection
            setTimeout(() => {
                if (!controllerConnections.has(id)) {
                    playerNumbers.delete(id);
                    console.log('Player number released:', id);
                    updateControllerDisplay();
                }
            }, PLAYER_RESERVATION_TIME);

            console.log('Controller disconnected:', id, '- Remaining:', controllerConnections.size);
            updateControllerDisplay();

            // Auto-pause when no controllers
            if (controllerConnections.size === 0 && currentState === State.PLAYING && !isPaused) {
                console.log('No controllers, pausing...');
                setPause(true);
            }
        }

        function updateControllerDisplay() {
            const container = document.getElementById('controllers');
            container.innerHTML = '';
            const connected = new Map();
            playerNumbers.forEach((num, id) => connected.set(num, controllerConnections.has(id)));

            for (let i = 0; i < 4; i++) {
                const dot = document.createElement('div');
                dot.className = 'controller-dot';
                if (connected.has(i)) {
                    dot.classList.add(connected.get(i) ? 'active' : 'reserved', `player-${i}`);
                }
                container.appendChild(dot);
            }
        }

        initializePeer();

        // ============================================
        // QR CODE
        // ============================================
        let qrCodeGenerated = false;
        let cachedControllerUrl = null;

        function calculateQRSize() {
            return Math.max(Math.floor(Math.min(window.innerWidth, window.innerHeight) / 4), 120);
        }

        async function getControllerUrl() {
            if (cachedControllerUrl) return cachedControllerUrl;
            try {
                const res = await fetch('/api/network-info');
                const data = await res.json();
                if (data.url) { cachedControllerUrl = `${data.url}/controller.html`; return cachedControllerUrl; }
            } catch(e) { console.warn('Network info error:', e); }
            const url = new URL(window.location.href);
            url.pathname = url.pathname.replace(/[^/]*$/, 'controller.html');
            cachedControllerUrl = url.toString();
            return cachedControllerUrl;
        }

        async function generateQRCode(force = false) {
            if (qrCodeGenerated && !force) return;
            const qrDisplay = document.getElementById('qrCodeDisplay');
            const qrUrl = document.getElementById('qrUrl');
            const url = await getControllerUrl();
            const size = calculateQRSize();

            qrDisplay.innerHTML = '';
            qrDisplay.style.width = qrDisplay.style.height = size + 'px';
            document.getElementById('qrContainer').style.maxWidth = (size + 40) + 'px';

            new QRCode(qrDisplay, { text: url, width: size, height: size, colorDark: '#000', colorLight: '#FFF', correctLevel: QRCode.CorrectLevel.H });
            qrUrl.textContent = url;
            qrUrl.href = url;
            qrCodeGenerated = true;
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => qrCodeGenerated && generateQRCode(true), 150);
        });

        function showQRCode() { document.getElementById('qrContainer').classList.remove('hidden'); }
        function hideQRCode() { document.getElementById('qrContainer').classList.add('hidden'); }

        setTimeout(() => { generateQRCode(); showQRCode(); }, 500);

        // ============================================
        // GAME LOADING
        // ============================================
        function loadROM(gameData) {
            pendingROM = {
                source: gameData.romSource,
                name: gameData.romName.split('.').slice(0, -1).join('.'),
                core: gameData.core,
                biosSource: gameData.biosSource
            };
            setState(State.LOADING);
            initializeEmulator();
        }

        function resetToGameMenu() {
            // Save state before leaving (slot 0 for auto-save)
            saveState(0);
            setState(State.IDLE);
            broadcastToControllers({ type: 'stateUpdate', state: 'game-selection', gameName: null, isPaused: false, isResetting: true });
            setTimeout(() => window.location.reload(), 500);
        }

        // Save/load state functions (use underlying EmulatorJS APIs)
        async function saveState(slot) {
            if (!EJS_emulator?.gameManager || !EJS_emulator?.storage?.states) return;
            try {
                const state = EJS_emulator.gameManager.getState();
                const key = EJS_emulator.getBaseFileName() + `.state${slot}`;
                await EJS_emulator.storage.states.put(key, state);
                EJS_emulator.displayMessage?.(EJS_emulator.localization?.("SAVED STATE TO BROWSER") || "State saved");
            } catch (e) {
                console.warn('Save state failed:', e);
            }
        }

        async function loadState(slot) {
            if (!EJS_emulator?.gameManager || !EJS_emulator?.storage?.states) return;
            try {
                const key = EJS_emulator.getBaseFileName() + `.state${slot}`;
                const state = await EJS_emulator.storage.states.get(key);
                if (state) {
                    EJS_emulator.gameManager.loadState(state);
                    EJS_emulator.displayMessage?.(EJS_emulator.localization?.("LOADED STATE FROM BROWSER") || "State loaded");
                } else {
                    EJS_emulator.displayMessage?.("No saved state found");
                }
            } catch (e) {
                console.warn('Load state failed:', e);
            }
        }

        // Audio unlock
        let hasUserInteraction = false;
        function hideAudioIndicator() { document.getElementById('audioMutedIndicator').classList.remove('visible'); }
        function showAudioIndicator() { document.getElementById('audioMutedIndicator').classList.add('visible'); }

        ['click', 'touchstart', 'keydown', 'mousedown'].forEach(evt => {
            document.addEventListener(evt, function onInteraction() {
                hasUserInteraction = true;
                hideAudioIndicator();
                const ctx = EJS_emulator?.Module?.AL?.currentCtx?.audioCtx;
                if (ctx?.state === 'suspended') ctx.resume().then(() => EJS_emulator?.setVolume?.(1));
            }, { passive: true });
        });

        function initializeEmulator() {
            window.EJS_player = '#game';
            window.EJS_pathtodata = 'EmulatorJS/data/';
            window.EJS_startOnLoaded = true;
            window.EJS_volume = 1;
            window.EJS_DEBUG_XX = true;
            window.EJS_EXPERIMENTAL_NETPLAY = true;
            window.EJS_defaultControls = false;
            window.EJS_backgroundBlur = false;
            window.EJS_backgroundColor = '#1a1a1a';
            window.EJS_defaultOptions = { "save-state-location": "browser" };

            if (!pendingROM) { console.error('No ROM'); setState(State.IDLE); return; }
            window.EJS_gameName = pendingROM.name;
            window.EJS_gameUrl = pendingROM.source;
            window.EJS_core = pendingROM.core;
            if (pendingROM.biosSource) window.EJS_biosUrl = pendingROM.biosSource;

            window.EJS_Buttons = {
                playPause: true, restart: true, mute: true, settings: true, fullscreen: true,
                saveState: true, loadState: true, screenRecord: true, gamepad: true, cheat: true,
                volume: true, saveSavFiles: true, loadSavFiles: true, quickSave: true, quickLoad: true,
                screenshot: true, cacheManager: true, exitEmulation: false, netplay: true,
                resetToMenu: { visible: true, displayName: "Menu", icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>', callback: resetToGameMenu }
            };

            // Simplified auto-start
            window.EJS_ready = function() {
                console.log('EmulatorJS ready');
                function autoStart() {
                    if (EJS_emulator?.started) return;
                    const btn = document.querySelector('#game .ejs_start_button');
                    if (btn?.offsetParent) { btn.click(); return; }
                    setTimeout(autoStart, 200);
                }
                autoStart();
            };

            window.EJS_onGameStart = function() {
                console.log('Game started');
                setState(State.PLAYING);
                setTimeout(() => {
                    const ctx = EJS_emulator?.Module?.AL?.currentCtx?.audioCtx;
                    if (ctx?.state === 'suspended') {
                        if (hasUserInteraction) ctx.resume().catch(() => showAudioIndicator());
                        else showAudioIndicator();
                    }
                }, 500);
                // Auto-load saved state (slot 0)
                setTimeout(() => loadState(0), 1500);
            };

            // Handle EJS events - emulator already paused/played, just sync UI
            window.EJS_onCommand = function(evt) {
                const m = evt.method;
                // Button 19 = pause button press
                if (m === 'input.simulate' && evt.params?.button === 19 && (evt.params.state === 'pressed' || evt.params.value === 1)) {
                    syncPauseUI(!isPaused);
                }
                // Toggle commands
                if (m === 'control.toggle-pause' || m === 'control.togglePause' || m === 'togglePause') {
                    syncPauseUI(!isPaused);
                } else if (m === 'control.pause') {
                    syncPauseUI(true);
                } else if (m === 'control.play' || m === 'control.resume') {
                    syncPauseUI(false);
                }
            };

            const script = document.createElement('script');
            script.src = 'EmulatorJS/data/loader.js';
            document.body.appendChild(script);
        }

        // ============================================
        // GAME MENU LOADER
        // ============================================
        async function loadGameMenuComponent() {
            try {
                const res = await fetch('game-menu.html');
                const html = await res.text();
                const doc = new DOMParser().parseFromString(html, 'text/html');
                const script = doc.querySelector('script[type="module"]');
                if (script) {
                    const el = document.createElement('script');
                    el.type = 'module';
                    el.textContent = script.textContent;
                    document.head.appendChild(el);
                    await customElements.whenDefined('game-menu');
                    gameMenu = document.getElementById('gameMenu');
                    gameMenu?.addEventListener('gamestart', e => loadROM(e.detail));
                }
            } catch(e) { console.error('Failed to load game menu:', e); }
        }
        loadGameMenuComponent();
    </script>
</body>
</html>
